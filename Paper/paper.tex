\documentclass{jcgt}
\usepackage{tikz}
\usepackage{amsmath}
\definecolor{darkgreen}{RGB}{0,192,0}

\setciteauthor{Alan Wolfe}
\setcitetitle{GPU Efficient Texture Based Bezier Curve Evaluation}

% Mark submissions with the date of submission using the following line:
%\submitted{\today}

% Once an article is accepted accepted, switch to the following line and comment the preceding one. The editor will supply the argument values.
\accepted{2014-02-07}{2014-02-07}{2014-02-07}{Editor Name}{3}{1}{1}{1}{2014}
\seturl{http://jcgt.org/published/0003/01/01/}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

\usetikzlibrary{arrows.meta}
\tikzset{>={Latex[width=3mm,length=3mm]}}

\title{GPU Efficient Texture Based Bezier Curve Evaluation}

\author
       {Alan Wolfe\\Blizzard Entertainment}

\teaser{
  \begin{tikzpicture}[x=5in,y=1.7in]
    \node[anchor=south west,inner sep=0] at (0,0) {\includegraphics[width=5in,height=1.7in]{Teaser.png}};
    % representative line for where the quadratic bezier curve lives in the bilinear sampled texture
    \draw[yellow,->,line width=0.5mm]    (0.41,0.25) -- (0.58,0.75);
    \draw (0.08,0.25) node[] {\Huge{A}};
    \draw (0.25,0.25) node[] {\Huge{B}};
    \draw (0.08,0.75) node[] {\Huge{B}};
    \draw (0.25,0.75) node[] {\Huge{C}};    
  \end{tikzpicture}
  \caption{\textit{Left:} 2x2 texture containing control points for a quadratic Bezier curve in each color channel. \textit{Middle:} The texture as viewed with bilinear sampling. \textit{Right:} The resulting curves when sampling along the yellow line (Alpha curve omitted).}
  \label{fig:teaser}
}

\maketitle
\thispagestyle{firstpagestyle}

\begin{abstract}
\small
Modern graphics techniques expose internal parameters to allow re-use and to help seperate the technical implementation from artistic usage cases.  A popular choice is to expose parameters as customizable curves and to quantize the curves into textures.  This leads to either lower quality results, or more texture memory being used to accomodate higher sampling frequencies.  The technique presented in this paper leverages the capabilities of GPU texture samplers to allow more efficient storage and evaluation of both integral and rational Bezier curves of any order, resulting in higher fidelity for the same costs.  Piecewise curves, B-Splines and Nurbs are mentioned, and there are also limited applications towards vector graphics.
\end{abstract}


%-------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}
There are two basic ways for a shader program to gain access to customized curve data.  One way is to evaluate the curve on the CPU at discrete intervals and put those points into a texture that can be used by the GPU.  The other way is to pass curve control point data from the CPU to the shader program as shader constants.

Baking curve points into a texture means that the shader program doesn't need to know what type of curve it was that made the data, nor how many control points it has, but comes at the loss of quality since there are a finite number of curve points sampled, and the data between points is just a linear interpolation between the samples.  If higher quality is desired, you can achieve this by increasing the resolution of the texture to be able to trade accuracy for texture memory.

Passing control point data to a shader program as shader constants allows you to get high quality curve calculations, but comes at the cost of the shader program being written in a very specific way for the type of curve you want to use, as well as more shader program instructions to calculate specific curve points.

\begin{figure}
  \includegraphics[width=5in]{Figure2.png}
  \caption{\textit{Left:} A quadratic Bezier curve written to the green channel, and the baked out equivelant using 4 pixels written to the red channel.  \textit{Right:} The technique from this paper, also using 4 pixels, written to the green channel, and the baked out equivelant written to the red channel again for comparison. \label{fig:sampleconfig}}
  \label{fig:quickcomparison}
\end{figure}

This paper shows a third method where:
\begin{itemize}
  \item Curve data is encoded within a texture in such a way to allow the texture sampler to calculate points on the curve before the data reaches the shader program.
  \item It gives accuracy results closer to that of shader constant curves, while having less calculation overhead.
  \item The technique can support both integral and rational Bezier curves of any order and can also be used for piecewise curves.
  \item The curve type must be decided on in advance, like when using the shader constant method.
  \item There are limited applications towards vector graphics.
\end{itemize}

A quick comparison of the visual quality of these three techniques can be seen in \autoref{fig:quickcomparison}.

%-------------------------------------------------------------------------
\section{The Technique}
\label{sec:thetechnique}

The core of this technique is that the linear texture interpolation capabilities on the GPU can be mathematically equivelant to De Casteljeau's algorithm for evaluating Bezier curves.

A one dimensional texture with linear sampling results in the evaluation of a linear Bezier curve (order 1), a two dimensional texture with linear sampling can result in a quadratic bezier curve (order 2), and a three dimensional texture (volumetric texture) with linear sampling can result in a cubic Bezier curve (order 3).

The pattern continues for higher dimensionality textures, and curves of lower degrees can be combined in the shader program to create curves of higher degrees by either continuing De Casteljeau's algorithm or by using the Bernstein form of Bezier curves.

\subsection{Intuition}

The De Casteljeau algorithm shows us that we can find points on a Bezier curve by evaluating a hierarchy of linear interpolations.  For example, a quadratic curve is the linear interpolation between the linear interpolation of {$\overline{AB}$} and {$\overline{BC}$}, using the same time $t$ for each interpolation.

Bilinear interpolation is used when linear sampling is enabled and a texture sample is taking from a 2d texture.  Bilinear interpolation is achieved by linearly interpolating across one axis (say, the X axis) and then interpolating the two results by the other axis (the Y axis).  In bilinear interpolation, you have a $t$ and a $u$ interpolation value, and you have four values to interpolate between $A$,$B$,$C$,$D$.

\begin{lstlisting}[caption={GLSL implementation of bilinear interpolation and the De Casteljeau algorithm for a quadratic Bezier curve.}, label={lst:GLSLCurves}]
float BilinearInterpolate (
  in float u, in float v,
  in float A, in float B, in float C, in float D
) {
    return mix(mix(A,B,u), mix(C,D,u), v);
}

float QuadraticBezier (
  in float t,
  in float A, in float B, in float C
) {
    return mix(mix(A,B,t), mix(B,C,t), t);
}
\end{lstlisting}

Comparing the source code for these two operations  (\autoref{lst:GLSLCurves}), we begin to get an idea of how to set up the points in our texture and the u and v coordinates to use such that when performing bilinear sampling, that we will get, as output, points on a quadratic bezier curve (\autoref{fig:decasteljeauBilinear}).

  \begin{figure}
    % bezier curve diagram
    \begin{tikzpicture}[x=4cm,y=4cm]
      % border
      \draw (-0.2,-0.2) -- (1.2,-0.2) -- (1.2,1.2) -- (-0.2,1.2) -- (-0.2,-0.2);
      % 1d quadratic bezier curve with control points 0,1,0
      \draw[scale=1,domain=0:1,smooth,variable=\x,blue,line width=0.5mm] plot ({\x},{2*\x-2*\x*\x});    
      % control polygon / labels
      \draw[red,->]       (0.0,0.0) -- (0.5,1.0);
      \draw[darkgreen,->] (0.5,1.0) -- (1.0,0.0);
      \draw[red]          (0.25,0.5) node[anchor=east] {$\overline{AB}$};
      \draw[darkgreen]    (0.75,0.5) node[anchor=west] {$\overline{BC}$};
      % control point labels
      \draw (0.0,0.0) node[anchor=east]  {\bf{A}};
      \draw (0.5,1.0) node[anchor=south] {\bf{B}};
      \draw (1.0,0.0) node[anchor=west]  {\bf{C}};
      % draw a line from AB->AC for time = 0.75
      \draw[orange,->] (0.3,0.6) -- (0.8,0.4);
      \draw[orange] (0.40,0.55) node[anchor=south west] {$\stackrel{\frown}{ABC}$};
      % draw the point at t=0.6 and label underneath the curve
      \draw[black,fill=black] (0.6,0.48) circle (1mm);
      \draw[black] (0.5,0.45) node[anchor=north] {\bf{t}=0.6};
    \end{tikzpicture}
    % bilinear diagram
    \begin{tikzpicture}[x=4cm,y=4cm]
        % border
        \draw (-0.2,-0.2) -- (1.2,-0.2) -- (1.2,1.2) -- (-0.2,1.2) -- (-0.2,-0.2);
        % box
        \draw (0,0) -- (1,0) -- (1,1) -- (0,1) -- (0,0);
        % representative line for where the quadratic bezier curve lives
        \draw[blue,line width=0.5mm] (0,0) -- (1,1);    
        % corner labels
        \draw (0,0) node[anchor=north east] {\bf{A}};
        \draw (1,0) node[anchor=north west] {\bf{B}};     
        \draw (0,1) node[anchor=south east] {\bf{B}};
        \draw (1,1) node[anchor=south west] {\bf{C}};     
        % x axis interpolation
        \draw[red,->]       (0.0,0.1) -- (1.0,0.1);
        \draw[red]          (0.4,0.1) node[anchor=south] {$\overline{AB}$};
        \draw[darkgreen,->] (0.0,0.9) -- (1.0,0.9);
        \draw[darkgreen]    (0.4,0.9) node[anchor=north] {$\overline{BC}$};
        % y axis interpolation
        \draw[orange,->]    (0.6,0.0) -- (0.6,1.0);
        \draw[orange]     (0.6,0.5) node[anchor=west] {$\stackrel{\frown}{ABC}$};
        % draw the point at t=0.6 and label for it
        \draw[black,fill=black] (0.6,0.6) circle (1mm);
        \draw[black] (0.55,0.6) node[anchor=east] {\bf{t}=0.6};
    \end{tikzpicture} 
    \caption{\textit{Left:} A quadratic Bezier curve evaluated at {\bf{t}}=0.6 for control points A,B,C using the De Casteljeau algorithm.  \textit{Right:} The De Casteljeau algorithm using bilinear interpolation.  Note that in this case, the X axis is evaluated before the Y, but the Y axis could be evaluated before the X for the same results.}
    \label{fig:decasteljeauBilinear}
  \end{figure}

Since we need to linearly interpolate between {$\overline{AB}$} and {$\overline{BC}$}, and between those results, all by the same time $t$, we need to ensure that our $u$ coordinate equals our $v$ coordinate.

It can be seen that the actual pixel value in a bilinear sampled texture is in the middle of a pixel.  That means that when calculating our texture coordinates we must sample between pixel location $(0.5,0.5)$ and pixel location $(1.5,1.5)$ to get the correct results.

The common pixel formats contain four color channels – Red, Green, Blue and Alpha – which allows us to be able to evaluate four curves with a single texture read (\autoref{fig:texbilcurve}).

  \begin{figure}
    \begin{tikzpicture}[x=12.5cm,y=4.25cm]
      % border
      \draw (0cm,0cm) -- (12.5cm,0cm) -- (12.5cm,4.25cm) -- (0cm,4.25cm) -- (0cm, 0cm);   
      % raw texture, bilinear sampled texture, curve results
        \node[anchor=south west,inner sep=0] at (0.125cm,0.125cm) {\includegraphics[width=4cm,height=4cm]{Figure4Texture.png}};
        \node[anchor=south west,inner sep=0] at (4.25cm,0.125cm) {\includegraphics[width=4cm,height=4cm]{Figure4Bilinear.png}};
        \node[anchor=south west,inner sep=0] at (8.375cm,0.125cm) {\includegraphics[width=4cm,height=4cm]{Figure4Curves.png}};
        % representative line for where the quadratic bezier curve lives
        \draw[yellow,->,line width=0.5mm]    (5.25cm,1.125cm) -- (7.25cm,3.125cm);    
        \draw (0.08,0.25) node[] {\Huge{A}};
        \draw (0.25,0.25) node[] {\Huge{B}};
        \draw (0.08,0.75) node[] {\Huge{B}};
        \draw (0.25,0.75) node[] {\Huge{C}};            
    \end{tikzpicture}
    \caption{\textit{Left:} a 2x2 texture storing control points for a quadratic Bezier curve in each color channel.  \textit{Middle:} The same texture as viewed when using bilinear texture sampling.  The yellow line indicates where texture samples are taken from to evaluate the quadratic Bezier curve. \textit{Right:} The curves resulting from sampling along the yellow line (Alpha curve ommited).}   
    \label{fig:texbilcurve}
  \end{figure}  

\subsection{Mathematical Basis}

The De Casteljeau algorithm is equivelant to the Bernstein form of Bezier curves.

\begin{equation}
\bf{P(t)} = \sum\limits_{i=0}^n\binom {n} {i}(1-t)^{n-i}t^i\text{\bf{P}}_i
\label{eqn:bernsteinform}
\end{equation}

That they are equivelant means that the Bernstein form for a given $n$ must also be able to be evaluated by $n$-Linear interpolation.  A linear curve should be able to be evaluated by linear interpolation, a quadratic curve should be able to be evaluated by bilinear interpolation, a cubic curve should be able to be evaluated by trilinear interpolation, and so on.

When $n$ is $1$, to make a linear Bezier curve, the equation we get out is in fact just linear interpolation, so we can see that it's true in that case.

\begin{equation}
\bf{P(t)} = P_0(1-t) + P_1t
\label{eqn:bernsteinformn1}
\end{equation}

When $n$ is $2$, to make a quadratic Bezier curve with bilinear interpolation, the relationship is not as obvious.

\begin{equation}
\bf{P(t)} = P_0(1-t)^2 + P_12(1-t)t + P_2t^2
\label{eqn:bernsteinformn2}
\end{equation}

To see how that equation can be the same as bilinear interpolation, let's start with the equation for bilinear interpolation, which is just a linear interpolation between two other linear interpolations.  We'll use $t$ and $u$ as the interpolation weights of each interpolation.

\begin{equation}
\begin{split}
\bf{E(u)} = P_0*(1-u) + P_1*u \\
\bf{F(u)} = P_2*(1-u) + P_3*u \\
\bf{P(t,u)} = E(u)*(1-t) + F(u)*t \\
\bf{P(t,u)} = (P_0*(1-u) + P_1*u)*(1-t) + (P_2*(1-u) + P_3*u)*t
\end{split}
\label{eqn:bilinearinterpolation}
\end{equation}

In our usage case of bilinear interpolation to evaluate Bernstein polynomials, $P_0$ will be $A$, $P_1$ and $P_2$ will both be $B$, and $P_3$ will be $C$.  Also, $t$ and $u$ are the same in our usage case so we'll just replace $u$ with $t$.  We will also replace $(1-t)$ with $s$ for readability.

\begin{equation}
\begin{split}
\bf{P(t)} = (A*s+B*t)*s + (B*s+C*t)*t \\
\bf{P(t)} = A*s^2+B*st + B*st+C*t^2 \\
\bf{P(t)} = A*s^2+B*2st+C*t^2
\end{split}
\label{eqn:bilinearinterpolation2}
\end{equation}

If we replace $A$,$B$,$C$ with $P_0$, $P_1$, $P_2$, and $s$ with $(1-t)$ we then get the familiar equation back out.

\begin{equation}
\bf{P(t)} = P_0(1-t)^2+P_12(1-t)t+P_2t^2
\label{eqn:bilinearinterpolation3}
\end{equation}

This pattern continues for trilinear interpolation and beyond

TODO: How to prove for N dimensions?  This section needs help
TODO: could somehow show how N-linear sampling is same as De Casteljeaus for all N's? tree diagram or something else.

\subsection{Accuracy}

While the Bernstein form of Bezier curves is equivelant to evaluating a Bezier curve with the De Casteljeau algorithm, in practice there are differences that come up between the two.  It is well known that the De Casteljeau algorithm is slower but more numerically robust than evaluating the Bernstein form.

The technique presented in this paper also has numerical differences in practice.  While it's been shown that the multidimensional linear interpolation capabilities can be mathematically equivelant to the Bernstein form as well as the De Casteljeau algorithm, there are mathematical precision issues due to current GPU architectures (\autoref{fig:quickaccuracy}).

As shown in \autoref{fig:texbilcurve}, the quality can be significantly higher than a baked out curve for the same number of pixels however.  There is more information on addressing accuracy in \autoref{sec:addressingaccuracyissues}.

  \begin{figure}
    \begin{tikzpicture}[x=12cm,y=4cm]
      % border
      \draw (0cm,0cm) rectangle (12cm,4cm);
      % raw texture, bilinear sampled texture, curve results
        \node[anchor=south west,inner sep=0] at (0cm,0cm) {\includegraphics[width=4cm,height=4cm]{HighQuality.png}};
        \node[anchor=south west,inner sep=0] at (4cm,0cm) {\includegraphics[width=4cm,height=4cm]{HighQualityZoom.png}};
        \node[anchor=south west,inner sep=0] at (8cm,0cm) {\includegraphics[width=4cm,height=4cm]{LowQualityZoom.png}};
        % representative line for where the quadratic bezier curve lives
        \draw[yellow] (0.11,0.35) rectangle (0.21,0.65);    
          
    \end{tikzpicture}
    \caption{\textit{Left:} Sampled curves.  \textit{Middle:} Zooming in on a curve calculated with shader program constants.  \textit{Right:} Zooming in on a curve calculated using the method in this paper}   
    \label{fig:quickaccuracy}
  \end{figure}  

TODO: give the details of the architecture imprecision sources and cite the two papers cited from the other place!

%-------------------------------------------------------------------------
\section{Texture Dimensionality}
\label{sec:texturedimensionality}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw] (char) {#1};}}

\begin{figure}
  \begin{tikzpicture}[level/.style={sibling distance = 5cm/#1, level distance = 1.5cm}] 
    \begin{scope}[shift={(-6cm,0)}]
      \node (Root) {\circled{ABCD}}
          child{ node{\circled{ABC}}
                  child{ node {\circled{AB}}
                    child{ node {\circled{A}}}
                    child{ node {\circled{B}}}            
                  }
                  child{ node {\circled{BC}}
                    child{ node {\circled{B}}}
                    child{ node {\circled{C}}}            
                  }                            
          }
          child{ node {\circled{BCD}}
                  child{ node {\circled{BC}}
                    child{ node {\circled{B}}}
                    child{ node {\circled{C}}}
                  }  
                  child{ node {\circled{CD}}
                    child{ node {\circled{C}}}
                    child{ node {\circled{D}}}
                  }  
          }
      ; 

      % Comments for each level
      \begin{scope}[every node/.style={right}]
        \path (Root      -| Root-2-2-2) ++(5mm,0) node {$\Rightarrow$} ++(5mm,0) node [blue] {Cubic curve / Trilinear sampling};
        \path (Root-1    -| Root-2-2-2) ++(5mm,0) node {$\Rightarrow$} ++(5mm,0) node [blue] {Quadratic curve / Bilinear sampling};
        \path (Root-1-1  -| Root-2-2-2) ++(5mm,0) node {$\Rightarrow$} ++(5mm,0) node [blue] {Linear curve / Linear sampling};
        \path (Root-1-1-1-| Root-2-2-2) ++(5mm,0) node {$\Rightarrow$} ++(5mm,0) node [blue] {Point / Nearest Neighbor};
      \end{scope}
    \end{scope}   
  \end{tikzpicture}
  \caption{A tree showing the De Casteljeau algorithm for a cubic curve.  The labels on the right show what type of curves are evaluated at that level, as well as the $N$ dimensional sampling that is required to evaluate nodes at that level with a single texture read.}
  \label{fig:decdimensionality}
\end{figure}  

While this technique is able to be used with any texture dimensionality, there are different characteristics for each choice.  Those characteristics will be explored here.

\subsection{One Dimensional Textures}

One dimensional textures are textures which have $W$ pixels in a single row or column, such as $(8,1)$, $(16,1)$ or more generally $(W,1)$.

Using one dimensional textures, the built in texture interpolation is only able to perform linear interpolation, which allows calculations of only 1st order (linear) Bezier basis functions (\autoref{fig:decdimensionality}).

If you want a Bezier curve higher than order $1$, you can take more texture samples and combine the results in the shader program.  While this is more expensive computationally than moving to a texture of higher dimensionality, it does have the benefit of doing more of the work in the shader program, which has higher precision through use of full float math, so the end result will be a higher quality curve.

The size of the one dimensional texture needed for $M$ piecewise curves, each of degree $N$ is $(N+1)*M$. For instance, a cubic (degree 3) curve requires 4 pixels ($(3+1)*1$).  If you want to encode two piecewise cubic curves end to end, it requires 8 pixels ($(3+1)*2$).

If $C0$ continuity is desired for piecewise curves, a redundant control point can be removed from the beginning of each curve after the first curve, which makes the size of texture required become $N*M+1$, requiring only 7 pixels for two cubic curves, instead of 8, or 10 pixels for three cubic curves, instead of 12 (\autoref{fig:texlayeout1d}).

  \begin{figure}
    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0) grid (4,1);
      \draw (0.5,0.5) node {$A$};
      \draw (1.5,0.5) node {$B$};
      \draw (2.5,0.5) node {$C$};
      \draw (3.5,0.5) node {$D$};
    \end{tikzpicture}

    \vspace{5mm}

    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0) grid (8,1);
      \draw (0.5,0.5) node {$A$};
      \draw (1.5,0.5) node {$B$};
      \draw (2.5,0.5) node {$C$};
      \draw (3.5,0.5) node {$D$};
      \draw (4.5,0.5) node {$D$};
      \draw (5.5,0.5) node {$E$};
      \draw (6.5,0.5) node {$F$};
      \draw (7.5,0.5) node {$G$};     
    \end{tikzpicture}   
    \caption{\textit{Top:} A cubic curve with control points $A,B,C,D$ encoded in a 1d texture with a size of 4 pixels.  \textit{Bottom:} Two piecewise curves encoded in a 1d texture.  The control points for the first curve are $A,B,C,D$ and the control points for the second curve are $D,E,F,G$.  If C0 continuitiy is always desired between the curves, a redundant $D$ could be removed to store these curves in 7 pixels instead of 8. }    
    \label{fig:texlayeout1d}
  \end{figure}

In the case of a cubic curve with control points $A,B,C,D$, the one dimensional texture will be 4 pixels in size, and three texture reads will need to be done to get the interpolations for $\overline{AB},\overline{BC},\overline{CD}$.  Those will then need to be combined using either the De Casteljeau algorithm, or by using the Bernstein form of a quadratic Bezier curve (order 2) to elevate those three points from order 1 to order 3, to get the final point $\stackrel{\frown}{ABCD}$.

\begin{lstlisting}[caption={GLSL for evaluating a cubic curve encoded in a 4 pixel 1d texture.  Linear texture sampling used to evaluate the first level of the De Casteljeau algorithm, then the process is continued both with the De Casteljeau algorithm, as well as the Bernstein form of a quadratic Bezier curve.}, label={lst:GLSLCubicTexture1D}]
// 4 pixel 1d texture with control points encoded: A,B,C,D
uniform sampler1D uSampler; 
const float c_textureSize = 4.0;

vec4 CubicCurveFromTexture1D_DeCastelJeau(in float t) {
    vec4 AB = texture(uSampler, (t + 0.5) / c_textureSize);
    vec4 BC = texture(uSampler, (t + 1.5) / c_textureSize;
    vec4 CD = texture(uSampler, (t + 2.5) / c_textureSize);
    vec4 ABC = mix(AB, BC, t);
    vec4 BCD = mix(BC, CD, t);
    return mix(ABC, BCD, t);
}

vec4 CubicCurveFromTexture1D_Bernstein(in float t) {
    vec4 AB = texture(uSampler, (t + 0.5) / c_textureSize);
    vec4 BC = texture(uSampler, (t + 1.5) / c_textureSize);
    vec4 CD = texture(uSampler, (t + 2.5) / c_textureSize);
    float s = (1 - t);
    float s2 = s * s;
    float t2 = t * t;
    // Quadratic Bezier Curve = A*s*s + B*2*s*t + C*t*t
    return AB*s2 + BC*2.0*s*t + CD*t2;
}
\end{lstlisting}

\subsection{Two Dimensional Textures}

Two dimensional textures are textures which are $(W,H)$ pixels in size, such as $(8,8)$ or $(16,16)$ or $(32,4)$.

Using two dimensional textures allows the texture interpolator to perform bilinear interpolation, which allows calculations of 2nd order (quadratic) Bezier basis functions (\autoref{fig:decdimensionality}).

If you want a Bezier curve higher than order 2, once again you can take more texture samples and combine the results in the shader program.  While more computationally expensive that moving to a higher dimensionality texture, it again results in higher precision results due to more of the computation happening in full floating point precision.

The size of the two dimensional texture needed for $M$ piecewise curves, each of degree $N$ is $(2*M,N)$. For instance, a cubic (degree 3) curve will be $(2,3)$ pixels.  If you want to encode two piecewise cubic curves end to end, it requires $(4,3)$ pixels (\autoref{fig:texlayeout2d}).

  \begin{figure}
    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0) grid (2,-3);
      \draw (0.5,-0.5) node {$A$};
      \draw (1.5,-0.5) node {$B$};
      \draw (0.5,-1.5) node {$B$};
      \draw (1.5,-1.5) node {$C$};
      \draw (0.5,-2.5) node {$C$};
      \draw (1.5,-2.5) node {$D$};      
    \end{tikzpicture}
    \hspace{5mm}
    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0) grid (4,-3);
      \draw (0.5,-0.5) node {$A$};
      \draw (1.5,-0.5) node {$B$};
      \draw (0.5,-1.5) node {$B$};
      \draw (1.5,-1.5) node {$C$};
      \draw (0.5,-2.5) node {$C$};
      \draw (1.5,-2.5) node {$D$};  

      \draw (2.5,-0.5) node {$D$};
      \draw (3.5,-0.5) node {$E$};
      \draw (2.5,-1.5) node {$E$};
      \draw (3.5,-1.5) node {$F$};
      \draw (2.5,-2.5) node {$F$};
      \draw (3.5,-2.5) node {$G$};          
    \end{tikzpicture}
    \caption{\textit{Left:} A cubic curve with control points $A,B,C,D$ encoded in a 2d texture that is $(2,3)$ in size.  \textit{Right:} Two piecewise curves encoded in a 2d texture that is $(4,3)$ in size.  The control points for the first curve are $A,B,C,D$ and the control points for the second curve are $D,E,F,G$.} 
    \label{fig:texlayeout2d}
  \end{figure}  

\begin{lstlisting}[caption={GLSL for evaluating a cubic curve encoded in a $(2,4)$ pixel 2d texture.  Bilinear texture sampling used to evaluate the first two levesl of the De Casteljeau algorithm, then the process is continued both with the De Casteljeau algorithm, as well as the Bernstein form of a linear Bezier curve (lerp).}, label={lst:GLSLCubicTexture2D}]
// 2x4 2d texture, rounded to the nearest powers of 2 from 2x3.
uniform sampler2D uSampler; 
const vec2 c_textureSize = vec2(2.0,4.0);

vec4 CubicCurveFromTexture2D_DeCastelJeau(in float t) {
    vec4 ABC = texture(uSampler, (vec2(0.5, 0.5)+t) / c_textureSize);
    vec4 BCD = texture(uSampler, (vec2(0.5, 1.5)+t) / c_textureSize);
    return mix(ABC, BCD, t);
}

vec4 CubicCurveFromTexture2D_Bernstein(in float t) {
    vec4 ABC = texture(uSampler, (vec2(0.5, 0.5)+t) / c_textureSize);
    vec4 BCD = texture(uSampler, (vec2(0.5, 1.5)+t) / c_textureSize);
    float s = (1 - t);
    // Linear Bezier Curve = A*s + B*t
    return ABC*s + BCD*t;
}
\end{lstlisting}

\subsection{Three Dimensional Textures}

Three dimensional textures (often refered to as volumetric textures) are textures which are $(W,H,D)$ pixels in size such as $(8,8,2)$ or $(16,8,4)$.

Using three dimensional textures allows the texture interpolator to evaluate trilinear interpolation, which allows calculations of 3rd order (cubic) Bezier basis functions (\autoref{fig:decdimensionality}).

Again, you can take more texture samples and combine the results in the shader program to get higher than order 3 curves if desired.

You may have noticed that a 1d texture can store a linear curve, but that a 2d texture cannot.  The lowest order curve it can store is a quadratic curve.  In the case of a 3d texture, the minimum goes up again, and the lowest order curve you can store is a cubic curve.

The size of the three dimensional texture needed for $M$ piecewise curves, each of degree $N$ is $(2*M,N-1,2)$. For instance, a cubic (degree 3) curve will be $(2,2,2)$ pixels.  If you want to encode two piecewise cubic curves end to end, it requires $(4,2,2)$ pixels (\autoref{fig:texlayeout3d}).

\begin{figure}
    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0,0) grid (2,-2,0);
      \draw (0.5,-0.5) node {$A$};
      \draw (1.5,-0.5) node {$B$};
      \draw (0.5,-1.5) node {$B$};
      \draw (1.5,-1.5) node {$C$};

      \begin{scope}[shift={(0.75,0.75,0)}]
        \draw[step=1cm,gray,dashed] (0,0,0) grid (2,-2,0);
        \draw[gray] (0.5,-0.5) node {$B$};
        \draw[gray] (1.5,-0.5) node {$C$};
        \draw[gray] (0.5,-1.5) node {$C$};
        \draw[gray] (1.5,-1.5) node {$D$};
      \end{scope}

      \draw[dashed] (0,0,0) -- (0.75, 0.75,0);
      \draw[dashed] (2,0,0) -- (2.75, 0.75,0);
      \draw[dashed] (0,-2,0) -- (0.75,-1.25,0);
      \draw[dashed] (2,-2,0) -- (2.75,-1.25,0);
    \end{tikzpicture}
    \hspace{5mm}
    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0,0) grid (4,-2,0);
      \draw (0.5,-0.5) node {$A$};
      \draw (1.5,-0.5) node {$B$};
      \draw (0.5,-1.5) node {$B$};
      \draw (1.5,-1.5) node {$C$};

      \draw (2.5,-0.5) node {$E$};
      \draw (3.5,-0.5) node {$F$};
      \draw (2.5,-1.5) node {$F$};
      \draw (3.5,-1.5) node {$G$};

      \begin{scope}[shift={(0.75,0.75,0)}]
        \draw[step=1cm,gray,dashed] (0,0,0) grid (4,-2,0);
        \draw[gray] (0.5,-0.5) node {$B$};
        \draw[gray] (1.5,-0.5) node {$C$};
        \draw[gray] (0.5,-1.5) node {$C$};
        \draw[gray] (1.5,-1.5) node {$D$};

        \draw[gray] (2.5,-0.5) node {$F$};
        \draw[gray] (3.5,-0.5) node {$G$};
        \draw[gray] (2.5,-1.5) node {$G$};
        \draw[gray] (3.5,-1.5) node {$H$};
      \end{scope}

      \draw[dashed] (0,0,0) -- (0.75, 0.75,0);
      \draw[dashed] (4,0,0) -- (4.75, 0.75,0);
      \draw[dashed] (0,-2,0) -- (0.75,-1.25,0);
      \draw[dashed] (4,-2,0) -- (4.75,-1.25,0);
    \end{tikzpicture}

    \vspace{5mm}

    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0,0) grid (2,-3,0);
      \draw (0.5,-0.5) node {$A$};
      \draw (1.5,-0.5) node {$B$};
      \draw (0.5,-1.5) node {$B$};
      \draw (1.5,-1.5) node {$C$};
      \draw (0.5,-2.5) node {$C$};
      \draw (1.5,-2.5) node {$D$};

      \begin{scope}[shift={(0.75,0.75,0)}]
        \draw[step=1cm,gray,dashed] (0,0,0) grid (2,-3,0);
        \draw[gray] (0.5,-0.5) node {$B$};
        \draw[gray] (1.5,-0.5) node {$C$};
        \draw[gray] (0.5,-1.5) node {$C$};
        \draw[gray] (1.5,-1.5) node {$D$};
        \draw[gray] (0.5,-2.5) node {$D$};
        \draw[gray] (1.5,-2.5) node {$E$};
      \end{scope}

      \draw[dashed] (0,0,0) -- (0.75, 0.75,0);
      \draw[dashed] (2,0,0) -- (2.75, 0.75,0);
      \draw[dashed] (0,-3,0) -- (0.75,-2.25,0);
      \draw[dashed] (2,-3,0) -- (2.75,-2.25,0);
    \end{tikzpicture}
    \hspace{5mm}
    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin] (0,0,0) grid (4,-3,0);
      \draw (0.5,-0.5) node {$A$};
      \draw (1.5,-0.5) node {$B$};
      \draw (0.5,-1.5) node {$B$};
      \draw (1.5,-1.5) node {$C$};
      \draw (0.5,-2.5) node {$C$};
      \draw (1.5,-2.5) node {$D$};

      \draw (2.5,-0.5) node {$F$};
      \draw (3.5,-0.5) node {$G$};
      \draw (2.5,-1.5) node {$G$};
      \draw (3.5,-1.5) node {$H$};
      \draw (2.5,-2.5) node {$H$};
      \draw (3.5,-2.5) node {$I$};

      \begin{scope}[shift={(0.75,0.75,0)}]
        \draw[step=1cm,gray,dashed] (0,0,0) grid (4,-3,0);
        \draw[gray] (0.5,-0.5) node {$B$};
        \draw[gray] (1.5,-0.5) node {$C$};
        \draw[gray] (0.5,-1.5) node {$C$};
        \draw[gray] (1.5,-1.5) node {$D$};
        \draw[gray] (0.5,-2.5) node {$D$};
        \draw[gray] (1.5,-2.5) node {$E$};


        \draw[gray] (2.5,-0.5) node {$G$};
        \draw[gray] (3.5,-0.5) node {$H$};
        \draw[gray] (2.5,-1.5) node {$H$};
        \draw[gray] (3.5,-1.5) node {$I$};
        \draw[gray] (2.5,-2.5) node {$I$};
        \draw[gray] (3.5,-2.5) node {$J$};
      \end{scope}

      \draw[dashed] (0,0,0) -- (0.75, 0.75,0);
      \draw[dashed] (4,0,0) -- (4.75, 0.75,0);
      \draw[dashed] (0,-3,0) -- (0.75,-2.25,0);
      \draw[dashed] (4,-3,0) -- (4.75,-2.25,0);
    \end{tikzpicture}

    \caption{\textit{Top Left:} A cubic curve encoded in a $(2,2,2)$ sized texture, decoded with a single trilinear texture sample. \textit{Top Right:}  Two piecewise cubic curves encoded in a $(4,2,2)$ sized texture, decoded with a single trilinear texture sample.  \textit{Bottom Left:} A Quartic curve encoded in a $(2,3,2)$ sized texture, decoded with two trilinear texture samples. \textit{Bottom Right:} Two piecewise quartic curves encoded in a $(4,3,2)$ sized texture, decoded with two trilinear texture samples.} 
    \label{fig:texlayeout3d}
  \end{figure}  

\begin{lstlisting}[caption={GLSL for evaluating a cubic curve encoded in a $(2,2,2)$ pixel 3d texture.  Trilinear texture sampling used to evaluate all three levels of the De Casteljeau algorithm.}, label={lst:GLSLCubicTexture3D}]
// 2x2x2 3d texture.
uniform sampler2D uSampler; 
const vec3 c_textureSize = vec3(2.0, 2.0, 2);

vec4 CubicCurveFromTexture3D(in float t) {
    return texture(uSampler, vec3(0.5 + t) / c_textureSize);
}
\end{lstlisting} 

\subsection{Summary of Texture Dimensionality}

TODO: TABLE to compare dimensionality
table details...

y axis =
 * 1d, 2d, 3d, 4d?

x axis =
 * minimum curve order storage
 * texture size formula
 * num texture samples taken for a quintic curve? sextent curve? or maybe do quadratic, cubic, quarticorder 4, order 5?
 * texture size for them too? dims and num pixels


TODO do we want images here at all? probably not i guess...

TODO: need to explain the layout of the pixels in the sections above somehow.  Maybe also get rid of describing what N-dimensional textures are

%-------------------------------------------------------------------------
\section{Extensions}
\label{sec:extensions}

There are a few ways to extend this technique for more options.

\subsection{Combining Color Channels}

TODO: this.  Higher order curves without more texture reads

\subsection{Piecewise Curves}

TODO: this.  Pros and cons. B-splines can be converted to piecewise Bezier with Boem's algorithm (what's it called again?).
TODO: how to actually evaluate piecewise curves! (GLSL if needed? or just describe it)

\subsection{Rational Bezier Curves}

TODO: this.
TODO: Nurbs can be converted to rational bezier curves with Boem's algorithm as well

\subsection{Multidimensional Bezier Curves}

TODO: this.  Each color channel is an axis.

%-------------------------------------------------------------------------
\section{Addressing Accuracy Issues}
\label{sec:addressingaccuracyissues}

TODO: this. HW vs SW vs HWSW hybrid vs read points yourself and do math w/o using interpolator. Everythign in between.
TODO: images to show differences.

%-------------------------------------------------------------------------
\section{Limited Applications for Vector Graphics}
\label{sec:limitedapplicationsforvectorgraphics}

TODO: this
TODO: mention that it isn't ideal since this technique is only good if you already know time "t" to evaluate, which is difficult to get otherwise.
TODO: mention that you don't have access to the control points since the interpolator does that level of math for you, but that affine transformations on the resulting curve point is equivelant to doing then on the control points.
TODO: mention 1d curve usage
TODO: mention polar curve usage
TODO: mention use for color gradients
TODO: picture of flag
TODO: put real usages here: particle properties, and whatever else.


%-------------------------------------------------------------------------
\section{Comparisons With Other Techniques}
\label{sec:comparisonswithothertechniques}

TODO: real apples to apples comparisons with texture baking (can be any order!) as well as shader constants.

%-------------------------------------------------------------------------
\section{Performance Characteristics}
\label{sec:performancecharacteristics}

TODO: Show some real performance values. 
TODO: show difference between 3d texture doing cubic, vs 2d texture with 2 texture reads and shader program results.
TODO: show results from multiple GPUs?

%-------------------------------------------------------------------------
\section*{Future Work}
\label{sec:futurework}

TODO: this

%-------------------------------------------------------------------------
\section*{Acknowledgements}
\label{sec:acknowledgements}
TODO: this


%-------------------------------------------------------------------------
\section*{References}
\label{sec:references}
TODO: this


%-------------------------------------------------------------------------
\section*{Index of Supplemental Materials}
\label{sec:indexofsupplementalmaterials}
TODO: this


%-------------------------------------------------------------------------
\section*{Author Contact Information}

\hspace{-2mm}\begin{tabular}{p{0.5\textwidth}p{0.5\textwidth}}
Roy G. Biv \newline
Colortech, Inc. \newline
29 Red Blvd. \newline
New York, NY 10511 \newline
\href{mailto:roy@colortech.com}{roy@colortech.com}
&

Raymond Trace \newline
Graphica University \newline
37 Rue De Lambert \newline
Paris, 75009 France \newline
\href{mailto:rtrace@graphica.edu}{rtrace@graphica.edu} \newline
\href{http://graphica.edu/~rtrace}{http://graphica.edu/\textasciitilde rtrace}

\end{tabular}


\afterdoc

\end{document}
