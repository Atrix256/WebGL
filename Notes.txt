* clean up / organize curve demo code
* shadertoy 2d curve experiments?
* THEN: c++ opengl version, OR webGL vector graphics on geometry

Next:
 * combine all into a single demo.  choose order of curve, and how many curves end to end.  show fragment shader code on the page and texture size etc.
 * finish cubic4.html demo
 * N-cubic curves end to end
 * Higher order curve via more lerps & equation
 * equation only quadratic curve N-points (3 pixels per curve.  maybe loop the curve to show that trick?)
 * make control points into circles via "discard".
 * make a better starting curve for the "4 quadratic bezier curves" demo
 * put descriptions on the index page
 * pluralize title and heading in demos
 * compare to 1x16 curve bake out lerp version somehow (and any other competing methods you can find?)
  * could make a "1x16 baked" version for the demos?
  * search for other ways people do curves on GPU these days (ask game dev places?)
 * instead of "quadratic bezier equation" etc in the drop downs, mention that it does 3 texture lookups + that (as an example). make the drop downs explain what is being done.
 * call "4 cubic curves"   "4 cubic curves end to end" instead? same w/ quadratic

* make sure that C++ version also has "trilinear" sampling mode, with volume textures

! set up curves such that you can lerp the R,G,B,A curve points to get a higher order curve with a single read

? does the "cubic needs 3x2 not 4x2" thing have play with higher dimensionality curves?
 ! yes it does!

* do the "all web curve demos" items

* read papers in paper notes section

* do 2d curve rendering for quadratic bezier curves?
 * http://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html?m=1

* diff the html demos and make them as close as possible
* make sure all spaces, no tabs, in all demo files

* Make C++ opengl versions
 * make sure cubic curve uses volume textures!
 * need to do perf analasys between methods.
 ! use glfw library? whats the standard way to provide c++ source for OpenGL these days?

? texture wrap looping demo?

* show rick details when you have perf info.

? does this have play with bezier surfaces and pascals pyramid etc?

! rendering generic curves:
 * can render any 1d curve!  already can do it on a quad, could just teselate quad to make it conform to a surface (do a demo?)
 * might be able to render a 2d quadratic curve.
 ? other ways to render these curves? higher order 2d curves possible?
 * works great if you already know time "t" somehow.

* L1 norm of pascal triangle row is 2^N where N is the row number: https://math.stackexchange.com/questions/1272085/is-this-sequence-significant
* calculating Nth row of pascal triangle: http://stackoverflow.com/questions/15580291/how-to-efficiently-calculate-a-row-in-pascals-triangle

* pascals triangle: http://en.wikipedia.org/wiki/Pascal%27s_triangle
* binomial coefficients: https://en.wikipedia.org/wiki/Binomial_coefficient

? how does the # of taps change when using bilinear vs trilinear, quadrilinear and beyond?

=== all web curve demos ===

* normCoord.x, not sample, in: float h = sample > 0.5 ? -0.01 : 0.01;

* don't show control points in "texture" render view

* i think the finite difference implementation might be wrong, check it out by simulating it in shadertoy or something
 * make h be based on resolution or something
* smoothstep distance should use screen resolution or something. or make it "true" antialiasing somehow? read that one paper about aa of procedular shapes

* could possibly have draggable control points, and have them adjust the sliders values at the same time (or maybe, that's how the dragging actually works!)
 * or just get rid of sliders if control point dragging works

* make a "all zeros" or "clear" button to make all control points zero.  maybe underneath the control point sliders? maybe an "all ones" button too?

=== comparison info===

compare speed vs sending control points in a constant buffer.  also vs hard coded control points.

compare quality (and speed?) vs baking curve as 1x16?

 =====Paper Notes=====

* could do a "pure math" derivatives in linear curves setup instead of using dFdx.  Could also do more texture reads in the bilinear setup.

* when using this method, since the hardware does some of the interpolation for you, it makes it harder to do math that involves the control points (like derivative or integral)

* read other papers from http://jcgt.org/ to get an idea of the average published paper

? maybe josh grass can answer questions for you about writing the paper

* read these... possibly related and maybe reference-able?
 * http://research.microsoft.com/en-us/um/people/cloop/loopblinn05.pdf   <--- similar but different. uses bilinear texture coordinate interpolation.
 * http://http.developer.nvidia.com/GPUGems3/gpugems3_ch25.html
 * http://commaexcess.com/articles/6/vector-graphics-on-the-gpu

* some references here:
 * http://algorithmist.net/docs/subdivision.pdf


* if not (much) more efficient could call it "efficient texture encoding / decoding" instead of gpu efficient

* doing manual lerp, you only need 1 pixel per control point.
 * can do this pattern with vertical texture repeat on to make a looping curve!

A B
D C
E F
H G

A->B->C
C->D->E
E->F->G
G->H->A

! compare quality to doing 1x16

? is bilinear sampling "free" (need citation)
? what's the cost of 3 neighboring "nearest pixel" pixel samples, is it also "free"?

? possibly related and reference-able
 * http://research.microsoft.com/en-us/um/people/cloop/loopblinn05.pdf

* can do 4 1d curves, 2 2d curves, a 3d curve and a 1d curve, or a 4d curve

* usage case: particle properties over time
 * could possibly use R,G,B and encode this in A maybe?

* usage case: specular maps, etc? no more "single value", could put things on curves. parametrized by what though? viewing angle and other things?

* comapre volume texture cubic curve vs not volume texture (c++ opengl)

* Explicitly say that bilinear texture filtering can evaluate the equation of bilin interp (quadratic bezier)

* could sneak in that smoothstep is 0,0,1,1 cubic curve!

! mention that the "multi tear" approach is de casteljeaus algorithm

* benefits of end to end curves vs a higher degree curve
 * less computation to evaluate
 * can have discontinuities (dont share tangents) if desired (sometimes desired, more flexibility)
 * technically, could also make it not even share control points!
 * higher degree curves = more texture sampels needed.  End to end curves = fewer.

! cubic. don't need 4x2 image... it has the same coordinates next to eachother! 3x2 does it!

! can put the same upper right value as lower left and use texture wrap to make it looping?

! future quadrilinear (and beyond?) texture sampling means fewer texture lookups for this technique.

! size of bezier needed = M*2, N-1
 * M = # of curves end to end you want
 * N = # of control points you want on your curve (degree)
 * this is with bilinear sampling only, what about trilinear and beyond? (step up the pascal triangle. one less texture lookup)

=====DEMO NOTES=====
* chrome disable vsync
 * run with --disable-gpu-vsync
 * https://cesiumjs.org/2014/12/01/WebGL-Profiling-Tips/
 * didn't seem to work?!