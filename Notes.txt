Next:
 * N-cubic curves end to end
 * Higher order curve via more lerps & equation
 * equation only quadratic curve N-points (3 pixels per curve.  maybe loop the curve to show that trick?)
 * make control points into circles via "discard".
 * make a better starting curve for the "4 quadratic bezier curves" demo
 * put descriptions on the index page
 * pluralize title and heading in demos
 * compare to 1x16 curve bake out lerp version somehow (and any other competing methods you can find?)
  * could make a "1x16 baked" version for the demos?
  * search for other ways people do curves on GPU these days (ask game dev places?)

* do 2d curve rendering for quadratic bezier curves?
 * http://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html?m=1

* diff the html demos and make them as close as possible
* make sure all spaces, no tabs, in all demo files

* Make C++ opengl versions
 * make sure cubic curve uses volume textures!
 * need to do perf analasys between methods.
 ! use glfw library? whats the standard way to provide c++ source for OpenGL these days?

* show rick details when you have perf info.

=== perf info===

compare speed vs sending control points in a constant buffer.  also vs hard coded control points.

=== all web curve demos ===

* normCoord.x, not sample, in: float h = sample > 0.5 ? -0.01 : 0.01;

* don't show control points in "texture" render view

* i think the finite difference implementation might be wrong, check it out by simulating it in shadertoy or something
 * make h be based on resolution or something
* smoothstep distance should use screen resolution or something. or make it "true" antialiasing somehow? read that one paper about aa of procedular shapes

* could possibly have draggable control points, and have them adjust the sliders values at the same time (or maybe, that's how the dragging actually works!)

 =====Paper Notes=====

* if not (much) more efficient could call it "efficient texture encoding / decoding" instead of gpu efficient

* doing manual lerp, you only need 1 pixel per control point.
 * can do this pattern with vertical texture repeat on to make a looping curve!

A B
D C
E F
H G

A->B->C
C->D->E
E->F->G
G->H->A

! compare quality to doing 1x16

? is bilinear sampling "free" (need citation)
? what's the cost of 3 neighboring "nearest pixel" pixel samples, is it also "free"?

? possibly related and reference-able
 * http://research.microsoft.com/en-us/um/people/cloop/loopblinn05.pdf

* can do 4 1d curves, 2 2d curves, a 3d curve and a 1d curve, or a 4d curve

* usage case: particle properties over time
 * could possibly use R,G,B and encode this in A maybe?

* comapre volume texture cubic curve vs not volume texture (c++ opengl)

* Explicitly say that bilinear texture filtering can evaluate the equation of bilin interp (quadratic bezier)

* could sneak in that smoothstep is 0,0,1,1 cubic curve!

! mention that the "multi tear" approach is de casteljeaus algorithm

* benefits of end to end curves vs a higher degree curve
 * less computation to evaluate
 * can have discontinuities (dont share tangents) if desired (sometimes desired, more flexibility)
 * technically, could also make it not even share control points!

=====OTHER=====

! note that you changed the webgl-utils.js to update more requently!

=====DEMO NOTES=====
* chrome disable vsync
 * run with --disable-gpu-vsync
 * https://cesiumjs.org/2014/12/01/WebGL-Profiling-Tips/
 * didn't seem to work?!