<!--
    WebGL initialization and basic utility code is based on the source code found here:
    http://learningwebgl.com/blog/?page_id=1217

    The rest was written by myself: Alan Wolfe  awolfe@blizzard.com

    TODO:
    	* make a diagram of where the different items are on the texture!
        * make functions to sample stuff from the texture so it isn't a wall of code

        * make a "nearest" version too that does the curve formulas

        * make it have knowledge of texture size so we can multiply texture coordinates by that to work in pixel space.  this way, the terrain can be encoded in [0,0]->[4,2] and we can add more curves without breaking code!

		* make the art, instead of the curves that are there!
		* make shader code constant, instead of being built in a string!
        * remove unneeded code like pascals triangle etc
        * remove the UI, we don't need it! (make keep resolution, maybe add wireframe render, maybe add flag subdivision count?)
         * we might want to keep some UI options (like sampling mode!), since it could be interesting and useful to see. also resolution is important
        * make a waving flag with vector art on it, that you can zoom in and out of and orbit around.
          * maybe a polar encoded sun, over some green hills (close hill lighter, far hill darker) and a blue sky background? possibly ocean in BG too
          * animate the sun?
        * possibly make some areas shinier than others?
         * specular
        * any functionality needed to share w/ the demo.html -> put into a shared javascript file!
         * like shader generation and initialization?
        * AA options: none, quincunx (render 2x), 4 rook (render 4x)
         * should you reference quicunx or 4 rook anti aliasing?
        * with the curves constant (for those that are... hopefully all of them!), can make the usage more appropriate for "write once, read never, use many"
		* probably don't need push / pop matrix stuff
		* fix weird viewing angle.  Too large fov maybe?!
		* update text and tile on page etc		
		* look through code for todos
		* make a flag pole?
        ? is light normal stuff correct? could try drawing the flag normals and see
        * use mvMatrix instead of pMatrix, for moving around object? or for lighting? dunno look into it.
         * probably not
        * see if texture can be specified in a way such that GL knows it won't ever change?

    TODO: flag.png description
        * [1] 4 layers of background described by a single texture of multiple quadratic curves over time.
         * light green, dark gree, blue, then gradient colored sky above.
         * make the water shiny (higher specular)
         * light green should be hilly, dark green should be more mountainy
         * we have one more unused region! could add another hill, or could maybe add an island in the background
          * yeah, island! poking up from behind the blue, with the blue dipping down a bit at that point to make it look like it's resting in the water.
        * [2] polar encoded sun.
         * inside = shiny yellow (higher specular), outside = clip
         * animated geometry.
        * [3] castle is potentially linear curves.
         * under curve = dark grey, above curve = clip.
         * see then about how to do black doorway.
          * could make have multiple "dark grey" curves, and have a black one in the middle.
          * this would let you put in windows too!
        * each number in brackets represents one texture and one draw pass?

   

-->
<html>
<head>
<title>GPU Efficient Texture Based Bezier Curve Evaluation - Curves Features Demo</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    varying vec2 vTextureCoord;
    varying vec3 vNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;    
    uniform mat3 uNMatrix;
    
    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;

        // calculate normal
        vNormal = uNMatrix * aVertexNormal;
    }
</script>

<script id="flag-fs" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D uSampler;
    uniform vec2 uMaxTextureCoord;

    varying vec2 vTextureCoord;
    varying vec3 vNormal;   

    vec4 SamplePixel (vec2 pixel) {
    	return texture2D(uSampler, vec2(pixel / uMaxTextureCoord));
    }
    /*

	Texture Layout:
	  A A 
	  A A


	A = Landscape: 2x2, qudratic bezier curves end to end

    */

    vec3 DrawLandScape () {

        // sample the landscape curves
        float time = vTextureCoord.x;
		vec4 curveValues = SamplePixel(vec2(0.25 + time / 2.0));

        // calculate and return color
        vec3 outColor;
        if (vTextureCoord.y < curveValues.x)
            outColor = vec3(0.0,1.0,0.0);
        else if (vTextureCoord.y < curveValues.y)
            outColor = vec3(0.0,0.5,0.0);
        else if (vTextureCoord.y < curveValues.z)
            outColor = vec3(0.0,0.0,0.4);
        else if (vTextureCoord.y < curveValues.w)
            outColor = vec3(0.4,0.4,0.4);
        else
            outColor = vec3(1.0,0.5,0.3);

        return outColor;
    }

    void main(void) {
        // start off by drawing the landscape
        vec3 outColor = DrawLandScape();

        // apply lighting and return the final color
        float directionalLightWeighting = min(max(dot(normalize(vNormal), normalize(vec3(0.4,0.4,-1))), 0.0),1.0);
        vec3 lightWeighting = vec3(0.2,0.2,0.2) + vec3(0.8,0.8,0.8) * directionalLightWeighting;
        gl_FragColor = vec4(clamp(outColor*lightWeighting,0.0,1.0), 1.0);
    }

</script>

<script type="text/javascript">

    var gl;
    var g_frameCounter = 0;

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript)
            return null;

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3)
                str += k.textContent;
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment")
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        else if (shaderScript.type == "x-shader/x-vertex")
            shader = gl.createShader(gl.VERTEX_SHADER);
        else
            return null;

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    var FSshaderProgram;

    function initShaders() {
        // make the full screen shader program
        {
	        var fragmentShader = getShader(gl, "flag-fs");
	        var vertexShader = getShader(gl, "shader-vs");

	        FSshaderProgram = gl.createProgram();
	        gl.attachShader(FSshaderProgram, vertexShader);
	        gl.attachShader(FSshaderProgram, fragmentShader);
	        gl.linkProgram(FSshaderProgram);

	        if (!gl.getProgramParameter(FSshaderProgram, gl.LINK_STATUS))
	            alert("Could not initialise FS shader");

	        gl.useProgram(FSshaderProgram);

	        FSshaderProgram.vertexPositionAttribute = gl.getAttribLocation(FSshaderProgram, "aVertexPosition");
	        gl.enableVertexAttribArray(FSshaderProgram.vertexPositionAttribute);

        	FSshaderProgram.vertexNormalAttribute = gl.getAttribLocation(FSshaderProgram, "aVertexNormal");
        	gl.enableVertexAttribArray(FSshaderProgram.vertexNormalAttribute);

	        FSshaderProgram.textureCoordinateAttribute = gl.getAttribLocation(FSshaderProgram, "aTextureCoord");
	        gl.enableVertexAttribArray(FSshaderProgram.textureCoordinateAttribute);

	        FSshaderProgram.samplerUniform = gl.getUniformLocation(FSshaderProgram, "uSampler");
	        FSshaderProgram.maxTextureCoordUniform = gl.getUniformLocation(FSshaderProgram, "uMaxTextureCoord");

	        FSshaderProgram.pMatrixUniform = gl.getUniformLocation(FSshaderProgram, "uPMatrix");
	        FSshaderProgram.mvMatrixUniform = gl.getUniformLocation(FSshaderProgram, "uMVMatrix");
	        FSshaderProgram.nMatrixUniform = gl.getUniformLocation(FSshaderProgram, "uNMatrix");
	    }
    }

    function createTexture(byteArrayWithRGBAData, width, height) {
        var filter = (document.getElementById("SamplingMode").value == "bilinear")
            ? gl.LINEAR
            : gl.NEAREST;

        var data = new Uint8Array(byteArrayWithRGBAData);
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    var bezierTexture;
    var g_controlPoints = [
        [128,   0,  50, 190],
        [  0, 255,   0,   0],
        [190,  64, 255,  75]
    ];

    var g_textureData = [
	    127,0,51,191,
	    0,255,0,0,
	    0,255,0,0,
	    191,64,255,74
    ];

    var g_textureSizeX = 2;
    var g_textureSizeY = 2;

    var screenQuadBuffer;
    var screenQuadNormalBuffer;
    var screenQuadTextureCoordinateBuffer;

    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();    

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }   

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(FSshaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(FSshaderProgram.mvMatrixUniform, false, mvMatrix);

        var normalMatrix = mat3.create();
        mat4.toInverseMat3(pMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(FSshaderProgram.nMatrixUniform, false, normalMatrix);        
    }    

    function GetBias(time,bias)
    {
        return (time / ((((1.0/bias) - 2.0)*(1.0 - time))+1.0));
    }  

    function getZ (x, y)
    {
    	var envelope = (1-x) / 0.25;
        if (envelope < 0)
            envelope = 0;
    	if (envelope > 1)
    		envelope = 1;

        // make it a bit non linear to help hide the envelope seam
        envelope = GetBias(envelope, 0.6);

    	if (g_timeMs < 1000)
    		envelope *= g_timeMs / 1000;

    	var xWave = Math.sin((x+g_timeMs / 500)*5) * envelope;
    	var yWave = Math.sin((y+g_timeMs / 1376)*12) * 0.2 * envelope;

        return xWave + yWave;
    }

    var scaleX = 10;
    var scaleY = 5;
    function PushVert (vertices,x,y)
    {
        vertices.push((x - 0.5) * scaleX, (y - 0.5) * scaleY, getZ(x,y));
    }

    function PushNormal (vertices,normals,x,y)
    {
		var h = 0.001;		
		var up     = [x,y+h,0];
		var p      = [x,y,0];
        var vright = [x+h,y,0];

		vright[2] = getZ(vright[0], vright[1]);
		up[2]    = getZ(up[0], up[1]);
		p[2]     = getZ(p[0], p[1]);

        vright[0] *= scaleX;
        vright[1] *= scaleY;
        p[0] *= scaleX;
        p[1] *= scaleY;
        up[0] *= scaleX;
        up[1] *= scaleY;

        var v1 = [0,0,0];
        var v2 = [0,0,0];
        vec3.subtract(p, vright, v1);
        vec3.subtract(p, up, v2);

		norm = vec3.normalize(vec3.cross(v1,v2));

		normals.push(norm[0], norm[1], norm[2]);
    }

    var flagNumCells = 20;
    function initBuffers() {
	    // TODO: review usage (gl.STATIC_DRAW)
        vertices = new Array;
        textureCoords = new Array;
        var delta = 1.0 / flagNumCells;
		for (y = 0; y < flagNumCells; ++y)
		{
			var percenty = y / flagNumCells;
	        for (x = 0; x < flagNumCells; ++x)
	        {
	        	var percentx = x / flagNumCells;

                PushVert(vertices, percentx, percenty);
				PushVert(vertices, percentx + delta, percenty);
				PushVert(vertices, percentx + delta, percenty + delta);

				textureCoords.push(percentx, percenty);
				textureCoords.push(percentx+delta, percenty);
				textureCoords.push(percentx+delta, percenty+delta);

				PushVert(vertices, percentx, percenty);
				PushVert(vertices, percentx + delta, percenty + delta);
				PushVert(vertices, percentx, percenty + delta);

				textureCoords.push(percentx, percenty);
				textureCoords.push(percentx+delta, percenty+delta);
				textureCoords.push(percentx, percenty+delta);
	        }
	    }

	    // calculate normals
        normals = new Array;	    
		for (y = 0; y < flagNumCells; ++y)
		{
			var percenty = y / flagNumCells;
	        for (x = 0; x < flagNumCells; ++x)
	        {
	        	var percentx = x / flagNumCells;

	        	PushNormal(vertices,normals,percentx,percenty);
	        	PushNormal(vertices,normals,percentx+delta,percenty);
	        	PushNormal(vertices,normals,percentx+delta,percenty+delta);

	        	PushNormal(vertices,normals,percentx,percenty);
	        	PushNormal(vertices,normals,percentx+delta,percenty+delta);
	        	PushNormal(vertices,normals,percentx,percenty+delta);
			}	    
		}

	    // make the vertex buffer
        screenQuadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);  
        screenQuadBuffer.itemSize = 3;
        screenQuadBuffer.numItems = vertices.length / screenQuadBuffer.itemSize;

	    // make the normal buffer
	    screenQuadNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);  
        screenQuadNormalBuffer.itemSize = 3;
        screenQuadNormalBuffer.numItems = normals.length / screenQuadNormalBuffer.itemSize;        
              
        // make the texture coordinate buffer
        screenQuadTextureCoordinateBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        screenQuadTextureCoordinateBuffer.itemSize = 2;
        screenQuadTextureCoordinateBuffer.numItems = textureCoords.length / screenQuadTextureCoordinateBuffer.itemSize;
    }

  	var g_timeMs = 0;
  	var g_lastTimeMs = 0;
    function animate() {

        if (document.getElementById("Animate").checked)
        {
	        var timeMs = new Date().getTime();
	        if (g_lastTimeMs != 0)
	        	g_timeMs += timeMs - g_lastTimeMs;
			g_lastTimeMs = timeMs;

        	initBuffers();			
		}
		else
		{
			g_lastTimeMs = 0;
		}
    }  

    var g_cameraRotX = 0;
    var g_cameraRotY = 0;
    var g_cameraZoom = 0.25;
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // perspective matrix
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.translate(pMatrix, [0.0, 0.0, - g_cameraZoom * 40]);
        mat4.rotate(pMatrix, g_cameraRotX * Math.PI * 2, [0,1,0]);
        mat4.rotate(pMatrix, g_cameraRotY * Math.PI * 2, [1,0,0]);

        // model view matrix!
		mat4.identity(mvMatrix);

        // draw the full screen quad
        gl.useProgram(FSshaderProgram);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, screenQuadBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadNormalBuffer);
        gl.vertexAttribPointer(FSshaderProgram.vertexNormalAttribute, screenQuadNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        gl.vertexAttribPointer(FSshaderProgram.textureCoordinateAttribute, screenQuadTextureCoordinateBuffer.itemSize, gl.FLOAT, false, 0, 0);        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bezierTexture);
        gl.uniform1i(FSshaderProgram.samplerUniform, 0);
		gl.uniform2f(FSshaderProgram.maxTextureCoordUniform, g_textureSizeX-1, g_textureSizeY-1);
        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLES,0,screenQuadBuffer.numItems);
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
       	animate();
        g_frameCounter++;
    }


    function initGL() {
        var canvas = document.getElementById("webglcanvas");
        var canvassize = document.getElementById("CanvasSize").value;
        canvas.width = canvassize*2;
        canvas.height = canvassize;
        // details of options below here: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
        gl = WebGLUtils.setupWebGL(canvas, {alpha:true, depth: true, stencil: false, antialias: false, premultipliedAlpha:false, preserveDrawingBuffer: false});

        gl.getExtension("OES_standard_derivatives");

        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);

        // TODO: do we want backface culling?
        //gl.enable(gl.CULL_FACE) 

        initShaders();
        initBuffers();

        gl.clearColor(0.4, 0.5, 0.6, 1.0);
    }

    function DoOnLoad() {
        initGL();
        setInterval(function(){ document.getElementById("fps").innerText = "FPS: " + g_frameCounter + " (" + Math.round(100 * 1000.0/g_frameCounter) / 100 + " ms)"; g_frameCounter = 0; }, 1000);

        // create the texture
        bezierTexture = createTexture(
            g_textureData,
            g_textureSizeX,
            g_textureSizeY
        );

        tick();
    }

    function ResizeCanvas() {
        initGL();
    }

    function OnChangeSettings()
    {
    	// TODO: this! for sampling mode changes
    }
</script>
</head>

<body onload="DoOnLoad()">
    <h1>GPU Efficient Texture Based Bezier Curve Evaluation - Curves Features Demo</h1>
    <a href="index.html">Back to Index</a><br><br>
    <table>
        <tr>
            <td>
                <table>
                    <tr>
                        <td>Sampling:</td>
                        <td>
                            <select id="SamplingMode" onChange="OnChangeSettings();">
                                <option value="bilinear">Bilinear</option>
                                <option value="nearest">Nearest (+2 Texture Reads)</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>Resolution:</td>
                        <td><select id="CanvasSize" onChange="ResizeCanvas();">
                            <option value="250">500x250</option>
                            <option value="500" selected="selected">1000x500</option>
                            <option value="750">1500x750</option>
                        </select>
                        </td>
                    </tr>
                </table>
            </td>
            <td>
                <table>
                    <tr>
                        <td>Animate</td>
                        <td><input id="Animate" type="checkbox" checked="true"></td>
                    </tr>                      
                    <tr>
                        <td colspan="2"><input type="button" value="Reset Time" onClick="g_timeMs = 0; initBuffers();"/></td>
                    </tr>
                </table>
            </td>
            <td>
                <table>
                    <tr>
                        <td>X</td>
                        <td><input type="range" min="0" max="100" onChange="g_cameraRotX = this.value/100;" onInput="g_cameraRotX = this.value/100;" value="0"/></td>
                    </tr>
                    <tr>
                        <td>Y</td>
                        <td><input type="range" min="0" max="100" onChange="g_cameraRotY = this.value/100;" onInput="g_cameraRotY = this.value/100;" value="0"/></td>
                    </tr>
                    <tr>
                        <td>Zoom</td>
                        <td><input type="range" min="0" max="100" onChange="g_cameraZoom = this.value/100;" onInput="g_cameraZoom = this.value/100;" value="25"/></td>
                    </tr>                                       
                </table>
            </td>
        </tr>
    </table>
    <div id="fps">FPS: --</div>
    <canvas id="webglcanvas" style="border: none" width="500" height="500"></canvas><br>
    <a href="index.html">Back to Index</a><br><br>
</body>

</html>