<!--
    WebGL initialization and basic utility code is based on the source code found here:
    http://learningwebgl.com/blog/?page_id=1217

    The rest was written by myself: Alan Wolfe  awolfe@blizzard.com

    TODO:
        * make a flag mesh
        * make flag mesh animate (z only?) over time
        * make 3d shapes work
        * remove control point rendering code
        * remove the UI, we don't need it! (make keep resolution, maybe add wireframe render, maybe add flag subdivision count?)
        * make a different aspect ratio for window, after UI is gone, so it fills more of the screen        
        * make a waving flag with vector art on it, that you can zoom in and out of and orbit around.
          * maybe a polar encoded sun, over some green hills (close hill lighter, far hill darker) and a blue sky background? possibly ocean in BG too
          * animate the sun?
        * 3d lighting
        * possibly make some areas shinier than others?
        * make the flag move realistically and unpredictably
        * any functionality needed to share w/ the demo.html -> put into a shared javascript file!
         * like shader generation and initialization
        * AA options: none, quincunx (render 2x), 4 rook (render 4x)
         * should you reference quicunx or 4 rook anti aliasing?
        * with the curves constant (for those that are... hopefully all of them!), can make the usage more appropriate for "write once, read never, use many"
		* probably don't need push / pop matrix stuff
		? is back face culling on? i don't think so... maybe should be!

    TODO: flag.png description
        * [1] 4 layers of background described by a single texture of multiple quadratic curves over time.
         * light green, dark gree, blue, then gradient colored sky above.
         * make the water shiny (higher specular)
         * light green should be hilly, dark green should be more mountainy
         * we have one more unused region! could add another hill, or could maybe add an island in the background
          * yeah, island! poking up from behind the blue, with the blue dipping down a bit at that point to make it look like it's resting in the water.
        * [2] polar encoded sun.
         * inside = shiny yellow (higher specular), outside = clip
         * animated geometry.
        * [3] castle is potentially linear curves.
         * under curve = dark grey, above curve = clip.
         * see then about how to do black doorway.
          * could make have multiple "dark grey" curves, and have a black one in the middle.
          * this would let you put in windows too!
        * each number in brackets represents one texture and one draw pass?

   

-->
<html>
<head>
<title>GPU Efficient Texture Based Bezier Curve Evaluation - Curves Features Demo</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    varying vec2 vTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;    

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>

<script type="text/javascript">

    var gl;
    var g_frameCounter = 0;

    function nextPowerOfTwo(v) {
        v = v-1;
        v|=v>>1;
        v|=v>>2;
        v|=v>>4;
        v|=v>>8;
        v|=v>>16;
        return v+1;
    }

    function pascalsTriangle(n)
    {
        var ret = [1];
        for (i = 0; i < n; ++i)
            ret.push(ret[i] * (n - i) / (i + 1));
        return ret;
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript)
            return null;

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3)
                str += k.textContent;
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment")
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        else if (shaderScript.type == "x-shader/x-vertex")
            shader = gl.createShader(gl.VERTEX_SHADER);
        else
            return null;

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function createFragmentShader(gl, source) {
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    var g_settings = {};

    function GetNumUIControlPoints ()
    {
        return (g_settings.m_desiredTextureSizeY + g_settings.m_orderBoost) * (g_settings.m_desiredTextureSizeX/2) + 1;
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }    

    var g_fragmentShaderHeader = 
        "#extension GL_OES_standard_derivatives : enable\n"+
        "precision mediump float;\n" + 
        "uniform sampler2D uSampler;\n" + 
        "varying vec2 vTextureCoord;\n\n" + 
        "void main(void) {\n";

    var g_fragmentShaderFooter = "}";

    function buildFragmentShader_texture () {
        var shaderSource = 
            g_fragmentShaderHeader +
            "   gl_FragColor = texture2D(uSampler, vTextureCoord);\n" + 
            g_fragmentShaderFooter;

        return createFragmentShader(gl,shaderSource);
    }

    function buildFragmentShader_visual (bilinear, curves, polar) {
        var shaderSource = "/*\n   Description:\n   " + g_settings.m_shaderDescription + "\n\n   Texture Layout:\n   " + g_settings.m_textureLayout + "\n*/\n\n" + g_fragmentShaderHeader;

        // convert to polar coordinates if we should
        if (polar) {
        	shaderSource +=
        		"   // Convert the texture coordinares from cartesian to polar space.\n" +
        		"   vec2 adjustedTextureCoord = (vTextureCoord - vec2(0.5)) * 2.0;\n" +
        		"   adjustedTextureCoord.x *= -1.0;\n" +
        		"   adjustedTextureCoord.y *= -1.0;\n" +
        		"   vec2 textureCoord;\n" +
        		"   textureCoord.x = (atan(adjustedTextureCoord.y, adjustedTextureCoord.x) + 3.14159265359) / 6.28318530718;\n" +
        		"   textureCoord.y = length(adjustedTextureCoord);\n\n";  
        }
        else {
        	shaderSource += "   vec2 textureCoord = vTextureCoord;\n\n";
        }

        // calculate how many texture samples there will be
        var textureSampleCount = bilinear ? g_settings.m_desiredTextureSizeY - 1 : g_settings.m_desiredTextureSizeY + 1;
        if (textureSampleCount < 1)
            textureSampleCount = 1;

        shaderSource += "   // Calculate the powers of s and t that we will need.\n";

        if (g_settings.m_desiredTextureSizeX > 2)
        {
        	shaderSource +=
        		"   float xOffset = floor(textureCoord.x * " + (g_settings.m_desiredTextureSizeX/2).toFixed(1) + ") * 2.0 / " + g_settings.m_actualTextureSizeX.toFixed(1) + ";\n" +
            	"   float t1 = fract(textureCoord.x * " + (g_settings.m_desiredTextureSizeX/2).toFixed(1) + ");\n";
        }
        else
        {
        	shaderSource +=
        		"   float xOffset = 0.0;\n" +
            	"   float t1 = textureCoord.x;\n";
        }

        var powersNeeded = textureSampleCount;
        if (powersNeeded < g_settings.m_orderBoost + 1)
            powersNeeded = g_settings.m_orderBoost + 1;

        if (powersNeeded > 1)
        {
            shaderSource +=
                "   float s1 = (1.0 - t1);\n";

            for (i = 2; i < powersNeeded; ++i) 
            {
                shaderSource += "   float t" + i.toString() + " = t" + (i-1).toString() + " * t1;\n";
                shaderSource += "   float s" + i.toString() + " = s" + (i-1).toString() + " * s1;\n";
            }
        }
        shaderSource += "\n";

        if (bilinear)
        {
            shaderSource +=
                "   // Calculate our sample value.\n" + 
                "   // The center of each pixel is where the color is.\n"+
                "   float sampleX = (0.25 + t1 / 2.0) / " + (g_settings.m_actualTextureSizeX / 2).toFixed(1) + " + xOffset;\n";

            // do the texture sample(s)
            if (textureSampleCount == 1)
            {
                shaderSource +=
                    "   float sampleY = (0.25 + t1 / 2.0);\n\n" +
                    "   // Do the texture sample\n" +
                    "   vec4 curveValues = texture2D(uSampler, vec2(sampleX, sampleY));\n\n";
            }
            else
            {
                shaderSource +=
                    "   float sampleY = (0.25 + t1 / 2.0) / " + (g_settings.m_actualTextureSizeY / 2).toFixed(1) + ";\n\n" +
                    "   // Do the texture samples\n";
                for (i = 1; i <= textureSampleCount; ++i)
                {
                    shaderSource += "   vec4 P" + i.toString() + " = texture2D(uSampler, vec2(sampleX, sampleY + " + (i-1).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n";
                }
                shaderSource += "\n";
            }
        }
        else
        {
            shaderSource += "   // Do the texture samples\n";
            for (i = 1; i < textureSampleCount; ++i)
            {
                shaderSource += "   vec4 P" + i.toString() + " = texture2D(uSampler, vec2(xOffset + 1.0 / " + (g_settings.m_actualTextureSizeX*2).toFixed(1) + ", " + (i-1).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n";
            }
            shaderSource += "   vec4 P" + textureSampleCount.toString() + " = texture2D(uSampler, vec2(xOffset + 3.0 / " + (g_settings.m_actualTextureSizeX*2).toFixed(1) + ", " + (textureSampleCount-2).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n\n";
        }

        // combine texture samples if we have multiple.  Otherwise we've already done all the work we need to do
        if (textureSampleCount > 1)
        {
            // Use the binomial theorem to generate the Nth order bezier curve function
            shaderSource += 
                "   // Calculate the desired bezier curve by putting the points we have through the appropriate bezier curve equation.\n";
            coefficients = pascalsTriangle(textureSampleCount-1);
            shaderSource += "   vec4 curveValues = \n";
            for (i = 1; i <= textureSampleCount; ++i)
            {
                shaderSource += "      P" + i.toString() + " * " + coefficients[i-1].toFixed(1);
                if (i > 1)
                    shaderSource += " * t" + (i-1).toString();

                var j = textureSampleCount - i + 1;
                if (j > 1)
                    shaderSource += " * s" + (j-1).toString();

                if ( i < textureSampleCount)
                    shaderSource += " +\n";
                else
                    shaderSource += ";\n\n";
            }
        }

        // combine color channels for order boost
        if (g_settings.m_orderBoost == 1) {
            shaderSource +=
                "   // Combine resulting pixels for +1 order boost\n" +
                "   curveValues.x = \n" +
                "       curveValues.x * 1.0 * s1 +\n" +
                "       curveValues.y * 1.0 * t1;\n" +
                "   curveValues.y = \n" +
                "       curveValues.z * 1.0 * s1 +\n" +
                "       curveValues.w * 1.0 * t1;\n\n";
        }
        else if (g_settings.m_orderBoost == 3) {
            shaderSource +=
                "   // Combine resulting pixels for +2 order boost\n" +
                "   curveValues.x = \n" +
                "       curveValues.x * 1.0 * s3 +\n" +
                "       curveValues.y * 3.0 * t1 * s2 +\n" +
                "       curveValues.z * 3.0 * t2 * s1 +\n" +
                "       curveValues.w * 1.0 * t3;\n\n";
        }

       if (curves) {
            shaderSource +=
                "   // Calculate slope using dfdx so we can use the gradient to aproximate distance\n" +
                "   vec4 slope = dFdx(curveValues) / dFdx(vTextureCoord.x);\n\n";
        }

        shaderSource +=
            "   // R,G,B curves add to their color channels respectively, alpha adds to all.\n" + 
            "   vec3 outColor;\n";

		if (curves) {
			shaderSource +=
            	"   outColor.x = smoothstep(0.01,0.0,abs(textureCoord.y - curveValues.x) / length(vec2(slope.x, -1.0)));\n";

            if (g_settings.m_orderBoost < 3)
            {
                shaderSource +=
                	"   outColor.y = smoothstep(0.01,0.0,abs(textureCoord.y - curveValues.y) / length(vec2(slope.y, -1.0)));\n";

                if (g_settings.m_orderBoost < 1)
                {
                    shaderSource +=
                    	"   outColor.z = smoothstep(0.01,0.0,abs(textureCoord.y - curveValues.z) / length(vec2(slope.z, -1.0)));\n" +
                    	"   float v = smoothstep(0.01,0.0,abs(textureCoord.y - curveValues.w) / length(vec2(slope.w, -1.0)));\n" +
                    	"   outColor.x += v;\n" +
                    	"   outColor.y += v;\n" +
                    	"   outColor.z += v;\n";
                }
                else
                {
                    shaderSource +=
                        "   outColor.z = 0.0;\n";
                }
            }
            else
            {
                shaderSource +=
                    "   outColor.y = 0.0;\n" +
                    "   outColor.z = 0.0;\n";
            }  	
		}
		else {
	        shaderSource += 
	            "   outColor.x = step(textureCoord.y, curveValues.x) * 0.5;\n";

            if (g_settings.m_orderBoost < 3)
            {
                shaderSource += 
    	            "   outColor.y = step(textureCoord.y, curveValues.y) * 0.5;\n";

                if (g_settings.m_orderBoost < 1)
                {
                    shaderSource +=
        	            "   outColor.z = step(textureCoord.y, curveValues.z) * 0.5;\n" +
        	            "   float v = step(textureCoord.y, curveValues.w) * 0.5;\n" +
        	            "   outColor.x += v;\n" +
        	            "   outColor.y += v;\n" +
        	            "   outColor.z += v;\n";
                }
                else
                {
                    shaderSource +=
                        "   outColor.z = 0.0;\n";
                }
            }
            else
            {
                shaderSource +=
                    "   outColor.y = 0.0;\n" +
                    "   outColor.z = 0.0;\n";
            }
		}

        shaderSource += 
            "\n" +
            "   // make the output color\n" +
            "   gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);\n" +
            g_fragmentShaderFooter;

        return createFragmentShader(gl,shaderSource);
    }

    function buildFragmentShader () {
        var renderMode = document.getElementById("RenderMode").value;
        if (renderMode == "texture")
            return buildFragmentShader_texture();

        var bilinear = (document.getElementById("SamplingMode").value == "bilinear");
        var curves = (renderMode == "curves");
        var polar = document.getElementById("RenderPolar").checked;
        return buildFragmentShader_visual(bilinear, curves, polar);

        alert("Could not find shader to generate");
        return null;
    }

    var FSshaderProgram;

    function initShaders() {
        // make the full screen shader program
        {
	        var fragmentShader = buildFragmentShader();
	        var vertexShader = getShader(gl, "shader-vs");

	        FSshaderProgram = gl.createProgram();
	        gl.attachShader(FSshaderProgram, vertexShader);
	        gl.attachShader(FSshaderProgram, fragmentShader);
	        gl.linkProgram(FSshaderProgram);

	        if (!gl.getProgramParameter(FSshaderProgram, gl.LINK_STATUS))
	            alert("Could not initialise FS shader");

	        gl.useProgram(FSshaderProgram);

	        FSshaderProgram.vertexPositionAttribute = gl.getAttribLocation(FSshaderProgram, "aVertexPosition");
	        gl.enableVertexAttribArray(FSshaderProgram.vertexPositionAttribute);

	        FSshaderProgram.textureCoordinateAttribute = gl.getAttribLocation(FSshaderProgram, "aTextureCoord");
	        gl.enableVertexAttribArray(FSshaderProgram.textureCoordinateAttribute);

	        FSshaderProgram.samplerUniform = gl.getUniformLocation(FSshaderProgram, "uSampler");

	        FSshaderProgram.pMatrixUniform = gl.getUniformLocation(FSshaderProgram, "uPMatrix");
	        FSshaderProgram.mvMatrixUniform = gl.getUniformLocation(FSshaderProgram, "uMVMatrix");
	    }
    }

    function createTexture(byteArrayWithRGBAData, width, height) {
        var filter = (document.getElementById("SamplingMode").value == "bilinear")
            ? gl.LINEAR
            : gl.NEAREST;

        var data = new Uint8Array(byteArrayWithRGBAData);
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    var bezierTexture;
    var g_controlPoints = [
        [128,   0,  50, 190],
        [  0, 255,   0,   0],
        [190,  64, 255,  75]
    ];

    function initTexture() {
        // Get the control point data from our sliders
        for (i = 0; i < GetNumUIControlPoints(); ++i)
        {
            g_controlPoints[i] = [
                document.getElementById("R"+i.toString()).value * 2.55,
                document.getElementById("G"+i.toString()).value * 2.55,
                document.getElementById("B"+i.toString()).value * 2.55,
                document.getElementById("A"+i.toString()).value * 2.55,
            ];
        }

        // make our texture data
        var textureData = new Array;

        if (g_settings.m_orderBoost == 0)
        {
            for (i = 0; i < g_settings.m_desiredTextureSizeY; ++i)
            {
                for (j = 0; j < g_settings.m_desiredTextureSizeX / 2; ++j)
                {
                	var offset = j * (g_settings.m_desiredTextureSizeY+g_settings.m_orderBoost);
                    textureData.push(g_controlPoints[i+offset][0]);
                    textureData.push(g_controlPoints[i+offset][1]);
                    textureData.push(g_controlPoints[i+offset][2]);
                    textureData.push(g_controlPoints[i+offset][3]);

                    textureData.push(g_controlPoints[i+offset+1][0]);
                    textureData.push(g_controlPoints[i+offset+1][1]);
                    textureData.push(g_controlPoints[i+offset+1][2]);
                    textureData.push(g_controlPoints[i+offset+1][3]);                    
                }

                for (j = g_settings.m_desiredTextureSizeX; j < g_settings.m_actualTextureSizeX; ++j)
                    textureData = textureData.concat([1,1,1,1]);
            }
        }
        else if (g_settings.m_orderBoost == 1)
        {
            for (i = 0; i < g_settings.m_desiredTextureSizeY; ++i)
            {
                for (j = 0; j < g_settings.m_desiredTextureSizeX / 2; ++j)
                {
                    var offset = j * (g_settings.m_desiredTextureSizeY+g_settings.m_orderBoost);
                    textureData.push(g_controlPoints[i+offset  ][0]);
                    textureData.push(g_controlPoints[i+offset+1][0]);
                    textureData.push(g_controlPoints[i+offset  ][1]);
                    textureData.push(g_controlPoints[i+offset+1][1]);

                    textureData.push(g_controlPoints[i+offset+1][0]);
                    textureData.push(g_controlPoints[i+offset+2][0]);
                    textureData.push(g_controlPoints[i+offset+1][1]);
                    textureData.push(g_controlPoints[i+offset+2][1]);                    
                }

                for (j = g_settings.m_desiredTextureSizeX; j < g_settings.m_actualTextureSizeX; ++j)
                    textureData = textureData.concat([1,1,1,1]);
            }
        }
        else if (g_settings.m_orderBoost == 3)
        {
            for (i = 0; i < g_settings.m_desiredTextureSizeY; ++i)
            {
                for (j = 0; j < g_settings.m_desiredTextureSizeX / 2; ++j)
                {
                    var offset = j * (g_settings.m_desiredTextureSizeY+g_settings.m_orderBoost);
                    textureData.push(g_controlPoints[i+offset  ][0]);
                    textureData.push(g_controlPoints[i+offset+1][0]);
                    textureData.push(g_controlPoints[i+offset+2][0]);
                    textureData.push(g_controlPoints[i+offset+3][0]);

                    textureData.push(g_controlPoints[i+offset+1][0]);
                    textureData.push(g_controlPoints[i+offset+2][0]);
                    textureData.push(g_controlPoints[i+offset+3][0]);
                    textureData.push(g_controlPoints[i+offset+4][0]);                    
                }

                for (j = g_settings.m_desiredTextureSizeX; j < g_settings.m_actualTextureSizeX; ++j)
                    textureData = textureData.concat([1,1,1,1]);
            }
        }

        // fill in the rest of the texture we had to allocate with opaque black.
        // we have to round up to the next even numbered texture size, which can cause this needing to happen.
        for (i = g_settings.m_desiredTextureSizeY; i < g_settings.m_actualTextureSizeY; ++i)
            for (j = 0; j < g_settings.m_actualTextureSizeX; ++j)
                textureData = textureData.concat([1,1,1,1]);

        // create the texture
        bezierTexture = createTexture(
            textureData,
            g_settings.m_actualTextureSizeX, g_settings.m_actualTextureSizeY
        );
    }

    var screenQuadBuffer;
    var screenQuadTextureCoordinateBuffer;

    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();    

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }   

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(FSshaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(FSshaderProgram.mvMatrixUniform, false, mvMatrix);
    }    

    var flagNumCells = 10;

    // todo: better flag waving
    function getZ (x, y)
    {
        return Math.sin((x+g_timeMs / 100)) * x + Math.sin((y+g_timeMs / 789)) * x;
    }

    function PushVert (vertices,x,y)
    {
        vertices.push((x - 0.5) * 5, (y - 0.5) * 5, getZ(x,y));
    }

    function initBuffers() {
	    // TODO: review usage (gl.STATIC_DRAW)
        vertices = new Array;
        textureCoords = new Array;
        var delta = 1.0 / flagNumCells;
		for (y = 0; y < flagNumCells; ++y)
		{
			var percenty = y / flagNumCells;
	        for (x = 0; x < flagNumCells; ++x)
	        {
	        	var percentx = x / flagNumCells;

                PushVert(vertices, percentx, percenty);
				PushVert(vertices, percentx + delta, percenty);
				PushVert(vertices, percentx + delta, percenty + delta);

				textureCoords.push(percentx, percenty);
				textureCoords.push(percentx+delta, percenty);
				textureCoords.push(percentx+delta, percenty+delta);

				PushVert(vertices, percentx, percenty);
				PushVert(vertices, percentx + delta, percenty + delta);
				PushVert(vertices, percentx, percenty + delta);

				textureCoords.push(percentx, percenty);
				textureCoords.push(percentx+delta, percenty+delta);
				textureCoords.push(percentx, percenty+delta);
	        }
	    }

	    // make the vertex buffer
        screenQuadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);  
        screenQuadBuffer.itemSize = 3;
        screenQuadBuffer.numItems = vertices.length / screenQuadBuffer.itemSize;
              
        // make the texture coordinate buffer
        screenQuadTextureCoordinateBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        screenQuadTextureCoordinateBuffer.itemSize = 2;
        screenQuadTextureCoordinateBuffer.numItems = textureCoords.length / screenQuadTextureCoordinateBuffer.itemSize;
    }

    function fromPolar(pos) {

    	var anglePercent = (pos[0] * 0.5 + 0.5);
    	var distancePercent = (pos[1] * 0.5 + 0.5);

    	return [
    		Math.cos(anglePercent * 2.0 * Math.PI) * distancePercent,
    		Math.sin(anglePercent* 2.0 * Math.PI) * distancePercent
		];
    }

  	var g_timeMs = 0;
    function animate() {
        g_timeMs = new Date().getTime();
        initBuffers();
    }  

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // perspective matrix
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.translate(pMatrix, [0.0, 0.0, -10.0]);

        // model view matrix!
		mat4.identity(mvMatrix);

        // draw the full screen quad
        gl.useProgram(FSshaderProgram);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, screenQuadBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        gl.vertexAttribPointer(FSshaderProgram.textureCoordinateAttribute, screenQuadTextureCoordinateBuffer.itemSize, gl.FLOAT, false, 0, 0);        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bezierTexture);
        gl.uniform1i(FSshaderProgram.samplerUniform, 0);
        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLES,0,screenQuadBuffer.numItems);
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
        g_frameCounter++;
    }

    var g_maxControlPoints = 0;

    function initSettings() {
        // calculate the texture size we need
        g_settings.m_desiredTextureSizeX = parseInt(document.getElementById("TextureSizeX").value);
        g_settings.m_desiredTextureSizeY = parseInt(document.getElementById("TextureSizeY").value);

        // round the texture size up to the next power of 2
        g_settings.m_actualTextureSizeX = nextPowerOfTwo(g_settings.m_desiredTextureSizeX);
        g_settings.m_actualTextureSizeY = nextPowerOfTwo(g_settings.m_desiredTextureSizeY);

        // other settings
        g_settings.m_orderBoost = parseInt(document.getElementById("OrderBoost").value);
        g_settings.m_drawControlPoints = document.getElementById("DrawControlPoints").checked;

        // show or hide sliders for control points, as needed
        var numUIControlPoints = GetNumUIControlPoints();
        var maxNumber = numUIControlPoints;
        if (maxNumber < g_maxControlPoints)
            maxNumber = g_maxControlPoints;
        g_maxControlPoints = maxNumber;

        for (i = 0; i < maxNumber; ++i)
        {
            var value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][0] == 'undefined') ? 0 : g_controlPoints[i][0] / 2.55;
            if (!document.getElementById("R"+i.toString())) {
            	var node = document.createElement("span");
            	node.setAttribute("id", "LR"+i.toString());
            	node.appendChild(document.createTextNode((i).toString() + ":"));
            	document.getElementById("RedControlPoints").appendChild(node);

            	node = document.createElement("input");
            	node.setAttribute("id", "R"+i.toString());
            	node.setAttribute("type", "range");
            	node.setAttribute("min", "0");
            	node.setAttribute("max", "100");
            	node.setAttribute("onInput", "initTexture();");
            	node.setAttribute("onChange", "initTexture();");
            	node.setAttribute("value", value);
				document.getElementById("RedControlPoints").appendChild(node);   

				document.getElementById("RedControlPoints").appendChild(document.createElement("br"));
            }
            var invisible = (i >= numUIControlPoints);
            document.getElementById("R" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";
            document.getElementById("LR" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";

            value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][1] == 'undefined') ? 0 : g_controlPoints[i][1] / 2.55;
            if (!document.getElementById("G"+i.toString())) {
            	var node = document.createElement("span");
            	node.setAttribute("id", "LG"+i.toString());
            	node.appendChild(document.createTextNode((i).toString() + ":"));
            	document.getElementById("GreenControlPoints").appendChild(node);

            	node = document.createElement("input");
            	node.setAttribute("id", "G"+i.toString());
            	node.setAttribute("type", "range");
            	node.setAttribute("min", "0");
            	node.setAttribute("max", "100");
            	node.setAttribute("onInput", "initTexture();");
            	node.setAttribute("onChange", "initTexture();");
            	node.setAttribute("value", value);
				document.getElementById("GreenControlPoints").appendChild(node);   

				document.getElementById("GreenControlPoints").appendChild(document.createElement("br"));            	
            }
            invisible = (i >= numUIControlPoints || g_settings.m_orderBoost > 1);
            document.getElementById("G" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";
            document.getElementById("LG" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";

            value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[2] == 'undefined') ? 0 : g_controlPoints[i][2] / 2.55;
            if (!document.getElementById("B"+i.toString())) {
            	var node = document.createElement("span");
            	node.setAttribute("id", "LB"+i.toString());
            	node.appendChild(document.createTextNode((i).toString() + ":"));
            	document.getElementById("BlueControlPoints").appendChild(node);

            	node = document.createElement("input");
            	node.setAttribute("id", "B"+i.toString());
            	node.setAttribute("type", "range");
            	node.setAttribute("min", "0");
            	node.setAttribute("max", "100");
            	node.setAttribute("onInput", "initTexture();");
            	node.setAttribute("onChange", "initTexture();");
            	node.setAttribute("value", value);
				document.getElementById("BlueControlPoints").appendChild(node);   

				document.getElementById("BlueControlPoints").appendChild(document.createElement("br"));              	
            }
            invisible = (i >= numUIControlPoints || g_settings.m_orderBoost > 0);
            document.getElementById("B" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";
            document.getElementById("LB" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";

            value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][3] == 'undefined') ? 0 : g_controlPoints[i][3] / 2.55;
            if (!document.getElementById("A"+i.toString())) {
            	var node = document.createElement("span");
            	node.setAttribute("id", "LA"+i.toString());
            	node.appendChild(document.createTextNode((i).toString() + ":"));
            	document.getElementById("AlphaControlPoints").appendChild(node);

            	node = document.createElement("input");
            	node.setAttribute("id", "A"+i.toString());
            	node.setAttribute("type", "range");
            	node.setAttribute("min", "0");
            	node.setAttribute("max", "100");
            	node.setAttribute("onInput", "initTexture();");
            	node.setAttribute("onChange", "initTexture();");
            	node.setAttribute("value", value);
				document.getElementById("AlphaControlPoints").appendChild(node);   

				document.getElementById("AlphaControlPoints").appendChild(document.createElement("br"));             	
            }
            document.getElementById("A" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";
            document.getElementById("LA" + i.toString()).style.visibility = (invisible) ? "hidden" : "visible";
        }

        document.getElementById("GreenControlPointsContainer").style.visibility = (g_settings.m_orderBoost > 1) ? "hidden" : "visible";
        document.getElementById("BlueControlPointsContainer").style.visibility = (g_settings.m_orderBoost > 0) ? "hidden" : "visible";
        document.getElementById("AlphaControlPointsContainer").style.visibility = (g_settings.m_orderBoost > 0) ? "hidden" : "visible";
    }


    function initGL() {
        var canvas = document.getElementById("webglcanvas");
        var canvassize = document.getElementById("CanvasSize").value;
        canvas.width = canvassize;
        canvas.height = canvassize;
        // details of options below here: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
        gl = WebGLUtils.setupWebGL(canvas, {alpha:true, depth: true, stencil: false, antialias: false, premultipliedAlpha:false, preserveDrawingBuffer: false});

        gl.getExtension("OES_standard_derivatives");

        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;

        initSettings();
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor(0.4, 0.5, 0.6, 1.0);
    }

    function DoOnLoad() {
        initGL();
        setInterval(function(){ document.getElementById("fps").innerText = "FPS: " + g_frameCounter + " (" + Math.round(100 * 1000.0/g_frameCounter) / 100 + " ms)"; g_frameCounter = 0; }, 1000);
        tick();
    }

    function ResizeCanvas() {
        initGL();
    }

    function OnChangeSettings()
    {
        initSettings();
        initShaders();
        initTexture();
    }

    function SetCPs (color, value)
    {
        for (i = 0; i < GetNumUIControlPoints(); ++i)
            document.getElementById(color+i.toString()).value = value;
        initTexture();
    }

    function SetCPsRandom (color)
    {
        for (i = 0; i < GetNumUIControlPoints(); ++i)
            document.getElementById(color+i.toString()).value = Math.random() * 100;
        initTexture();
    }
</script>
</head>

<body onload="DoOnLoad()">
    <h1>GPU Efficient Texture Based Bezier Curve Evaluation - Curves Features Demo</h1>
    <a href="index.html">Back to Index</a><br><br>
    <table>
        <tr>
            <td>
                <table>
                    <tr>
                        <td>Texture Size Y Axis (Order):</td>
                        <td>
                            <select id="TextureSizeY" OnChange="OnChangeSettings();">
                                <option value="1">1: Linear (Order 1)</option>
                                <option value="2" selected="selected">2: Quadratic (Order 2)</option>
                                <option value="3">3: Cubic (Order 3)</option>
                                <option value="4">4: Quartic (Order 4)</option>
                                <option value="5">5: Quintic (Order 5)</option>
                                <option value="6">6: Sextic (Order 6)</option>
                                <option value="7">7: Septic (Order 7)</option>
                                <option value="8">8: Octic (Order 8)</option>
                            </select>            
                        </td>
                    </tr>        
                    <tr>
                        <td>Texture Size X axis (# Curves):</td>
                        <td>
                            <select id="TextureSizeX" OnChange="OnChangeSettings();">
                                <option value="2">2: 1 curve  [T=0..1]</option>
                                <option value="4">4: 2 curves [T=0..2]</option>
                                <option value="6">6: 3 curves [T=0..3]</option>
                                <option value="8">8: 4 curves [T=0..4]</option>
                                <option value="10">10: 5 curves [T=0..5]</option>
                                <option value="12">12: 6 curves [T=0..6]</option>
                                <option value="14">14: 7 curves [T=0..7]</option>
                                <option value="16">16: 8 curves [T=0..8]</option>                                                                                                
                            </select>            
                        </td>
                    </tr>
                    <tr>
                        <td>Curves Per Pixel (Order Boost):</td>
                        <td>
                            <select id="OrderBoost" OnChange="OnChangeSettings();">
                                <option value="0">4: +0 order [R] [G] [B] [A]</option>
                                <option value="1">2: +1 order [R&amp;G], [B&amp;A]</option>
                                <option value="3">1: +3 order [R&amp;G&amp;B&amp;A]</option>
                            </select>           
                        </td>
                    </tr>
                </table>
            </td>
            <td>
                <table>
                    <tr>
                        <td>Sampling:</td>
                        <td>
                            <select id="SamplingMode" onChange="OnChangeSettings();">
                                <option value="bilinear">Bilinear</option>
                                <option value="nearest">Nearest (+2 Texture Reads)</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>Render:</td>
                        <td>
                            <select id="RenderMode" onChange="OnChangeSettings();">
                                <option value="halfspace">HalfSpace</option>
                                <option value="curves">Curves (dFdx for gradient distance)</option>
                                <option value="texture">Texture</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>Resolution:</td>
                        <td><select id="CanvasSize" onChange="ResizeCanvas();">
                            <option value="250">250x250</option>
                            <option value="500" selected="selected">500x500</option>
                            <option value="1000">1000x1000</option>
                        </select>
                        </td>
                    </tr>
                </table>
            </td>
            <td>
                <table>
                    <tr>
                        <td>Render Polar</td>
                        <td><input id="RenderPolar" type="checkbox" onChange="OnChangeSettings();"></td>
                    </tr>                
                    <tr>
                        <td>Show Control Points</td>
                        <td><input id="DrawControlPoints" type="checkbox"  checked="true" onChange="OnChangeSettings();"></td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
    <div id="fps">FPS: --</div>
    <table>
        <tr>
            <td valign="top">
                <canvas id="webglcanvas" style="border: none" width="500" height="500"></canvas>
            </td>
            <td valign="top" style="border:2px solid red" id="RedControlPointsContainer">
                Red:<br>
                <input type="button" onClick="SetCPs('R',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('R',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('R')" value="Random"/><br>
                <span id="RedControlPoints"></span>
            </td>
            <td valign="top" style="border:2px solid green" id="GreenControlPointsContainer">
                Green:<br>
                <input type="button" onClick="SetCPs('G',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('G',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('G')" value="Random"/><br>
                <span id="GreenControlPoints"></span>
            </td>
            <td valign="top" style="border:2px solid blue" id="BlueControlPointsContainer">                
                Blue:<br>
                <input type="button" onClick="SetCPs('B',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('B',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('B')" value="Random"/><br>
                <span id="BlueControlPoints"></span>
            </td>
            <td valign="top" style="border:2px solid black" id="AlphaControlPointsContainer">                
                Alpha:<br>
                <input type="button" onClick="SetCPs('A',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('A',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('A')" value="Random"/><br>
                <span id="AlphaControlPoints"></span>
            </td>
        </tr>
    </table><br>
    <a href="index.html">Back to Index</a><br><br>
</body>

</html>