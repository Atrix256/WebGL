<!--
	WebGL initialization and basic utility code is based on the source code found here:
	http://learningwebgl.com/blog/?page_id=1217

	The rest was written by myself: Alan Wolfe  awolfe@blizzard.com
-->
<html>
<head>
<title>GPU Efficient Texture Based Bezier Curve Evaluation</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = vec4(aVertexPosition, 1.0, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>

<script id="shader-vs-cp" type="x-shader/x-vertex">
    attribute vec2 aVertexPosition;
    uniform vec2 uOffset;

    varying vec2 vPosition;

    void main(void) {
        gl_Position = vec4(aVertexPosition+uOffset, 1.0, 1.0);
        vPosition = aVertexPosition;
    }
</script>

<script id="shader-fs-cp" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec3 uColor;

    varying vec2 vPosition;

    void main(void) {
        if (length(vPosition) > 0.024)
            discard;
        gl_FragColor = vec4(uColor,1.0);   
    }
</script>

<script type="text/javascript">

    var gl;
    var g_frameCounter = 0;

    function nextPowerOfTwo(v) {
        v = v-1;
        v|=v>>1;
        v|=v>>2;
        v|=v>>4;
        v|=v>>8;
        v|=v>>16;
        return v+1;
    }

    function pascalsTriangle(n)
    {
        var ret = [1];
        for (i = 0; i < n; ++i)
            ret.push(ret[i] * (n - i) / (i + 1));
        return ret;
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript)
            return null;

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3)
                str += k.textContent;
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment")
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        else if (shaderScript.type == "x-shader/x-vertex")
            shader = gl.createShader(gl.VERTEX_SHADER);
        else
            return null;

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function createFragmentShader(gl, source) {
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    var g_settings = {};

    var g_fragmentShaderHeader = 
        "precision mediump float;\n" + 
        "uniform sampler2D uSampler;\n" + 
        "varying vec2 vTextureCoord;\n\n" + 
        "void main(void) {\n";

    var g_fragmentShaderFooter = "}";

    function buildFragmentShader_texture () {
        var shaderSource = 
            g_fragmentShaderHeader +
            "   gl_FragColor = texture2D(uSampler, vTextureCoord);\n" + 
            g_fragmentShaderFooter;

        document.getElementById("ShaderSource").innerText = shaderSource;
        return createFragmentShader(gl,shaderSource);
    }

    function buildFragmentShader_halfspace (bilinear) {
    	var shaderSource = 
        	g_fragmentShaderHeader +
            "   // Calculate our sample value.\n" + 
            "   // The center of each pixel is where the value is, not the edge.\n";

        if (bilinear)
        	shaderSource += "   // Our interpolation goes from 0.25 -> 0.75, not from 0 to 1.\n";

		shaderSource +=
            "   float t1 = vTextureCoord.x;\n" +
            "   float sample = 0.25 + t1 / 2.0;\n\n";

        // TODO: combine this code better.  maybe move the s and t powers up. break things into multiple sections.  it's ok if we have multiple bilinear / non bilinear blocks.
        // TODO: make sure the comments in the output source code make sense.
        // TODO: handle special cases like linear still doing math on the sample, or adding 0/2 etc.  Make it not spit out dumb math that isn't needed.

        var textureSampleCount;
        if (bilinear)
        {
        	// calculate how many texture samples there will be
        	textureSampleCount = g_settings.m_desiredTextureSizeY - 1;
        	if (textureSampleCount < 1)
        		textureSampleCount = 1;

        	// do the texture sample(s)
        	if (textureSampleCount == 1)
        	{
        		shaderSource += "   // Do the texture sample\n";
				shaderSource += "   vec4 curveValues = texture2D(uSampler, vec2(sample));\n\n";
        	}
        	else
        	{
        		shaderSource += "   // Do the texture samples\n";
	        	for (i = 1; i <= textureSampleCount; ++i)
	        	{
					shaderSource += "   vec4 P" + i.toString() + " = texture2D(uSampler, vec2(sample, sample / " + (g_settings.m_actualTextureSizeY / 2).toFixed(1) + " + " + (i-1).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n";
	        	}
	        	shaderSource += "\n";
	        }
        }
        else
        {
        	// calculate how many texture samples there will be
        	textureSampleCount = g_settings.m_desiredTextureSizeY + 1;

        	// do the texture sample(s)
        	if (textureSampleCount == 1)
        	{
        		shaderSource += "   // Do the texture sample\n";
				shaderSource += "   vec4 curveValues = texture2D(uSampler, vec2(sample));\n\n";
        	}
        	else
        	{
        		shaderSource += "   // Do the texture samples\n";
	        	for (i = 1; i < textureSampleCount; ++i)
	        	{
					shaderSource += "   vec4 P" + i.toString() + " = texture2D(uSampler, vec2(1.0 / " + (g_settings.m_actualTextureSizeX*2).toFixed(1) + ", " + (i-1).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n";
	        	}
				// TODO: non bilinear case doesn't need the "sample" variables
				// TODO: that hard coded 3 / N is wrong.  it shouldn't be 3, what should it be? need to change it if having multiple textures in a row

				shaderSource += "   vec4 P" + textureSampleCount.toString() + " = texture2D(uSampler, vec2(3.0 / " + (g_settings.m_actualTextureSizeX*2).toFixed(1) + ", " + (textureSampleCount-2).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n";

	        	shaderSource += "\n";
	        }        	
        }

        // combine texture samples if we have multiple.  Otherwise we've already done all the work we need to do
        if (textureSampleCount > 1)
        {
            shaderSource += 
                "   // Calculate the powers of s and t that we will need.\n" +
                "   float s1 = (1.0 - t1);\n";

            for (i = 2; i < textureSampleCount; ++i) 
            {
                shaderSource += "   float t" + i.toString() + " = t" + (i-1).toString() + " * t1;\n";
                shaderSource += "   float s" + i.toString() + " = s" + (i-1).toString() + " * s1;\n";
            }
            shaderSource += "\n"

            // Use the binomial theorem to generate the Nth order bezier curve function
            shaderSource += 
                "   // Calculate the desired bezier curve by putting the points we have through the appropriate bezier curve equation.\n";
            coefficients = pascalsTriangle(textureSampleCount-1);
            shaderSource += "   vec4 curveValues = \n";
            for (i = 1; i <= textureSampleCount; ++i)
            {
                shaderSource += "      P" + i.toString() + " * " + coefficients[i-1].toFixed(1);
                if (i > 1)
                    shaderSource += " * t" + (i-1).toString();

                var j = textureSampleCount - i + 1;
                if (j > 1)
                    shaderSource += " * s" + (j-1).toString();

                if ( i < textureSampleCount)
                    shaderSource += " +\n";
                else
                    shaderSource += ";\n\n";
            }
        }

		shaderSource += 
            "   // R,G,B curves add 0.5 to their color channels respectively.\n" + 
            "   vec3 outColor;\n" +
            "   outColor.x = step(vTextureCoord.y, curveValues.x) * 0.5;\n" +
            "   outColor.y = step(vTextureCoord.y, curveValues.y) * 0.5;\n" +
            "   outColor.z = step(vTextureCoord.y, curveValues.z) * 0.5;\n\n" +
            "   // alpha curve adds 0.5 to each color channel\n" +
            "   float v = step(vTextureCoord.y, curveValues.w) * 0.5;\n" +
            "   outColor.x += v;\n" +
            "   outColor.y += v;\n" +
            "   outColor.z += v;\n\n" +
            "   // make the output color\n" +
            "   gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);\n" +
            g_fragmentShaderFooter;

        document.getElementById("ShaderSource").innerText = shaderSource;
		return createFragmentShader(gl,shaderSource);
    }

    function buildFragmentShader_bilinear_curves () {
        return createFragmentShader(gl,
            g_fragmentShaderHeader +
            "   // Calculate our sample value.\n" +
            "   // The center of each pixel is where the value starts, not the edge, so our interpolation\n" +
            "   // goes from 0.25 -> 0.75, not from 0 to 1.\n" +
            "   float sample = 0.25 + vTextureCoord.x / 2.0;\n\n" +
            "   // Evaluate the curve, using bilinear filtering to do bilinear interpolation to calculate our curve point.\n" +
            "   vec4 curveValues = texture2D(uSampler, vec2(sample));\n\n" +
            "   // use finite differences to get an aproximation of the slope of the curve at this point\n" +
            "   float h = sample > 0.5 ? -0.01 : 0.01;\n" +
            "   vec4 slope = (texture2D(uSampler, vec2(sample + h)) - curveValues) / h; \n\n" +
            "   // Use the slope to get the gradient, and use the gradient to get a distance estimation to the curves\n" +
            "   // R,G,B curves add 1.0 to their color channels respectively.\n" +
            "   vec3 outColor;\n" +
            "   outColor.x = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.x) / length(vec2(slope.x, -1.0)));\n" +
            "   outColor.y = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.y) / length(vec2(slope.y, -1.0)));\n" +
            "   outColor.z = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.z) / length(vec2(slope.z, -1.0)));\n\n" +
            "   // alpha curve adds 1.0 to each color channel\n" +
            "   float value = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.w) / length(vec2(slope.w, -1.0)));\n" +
            "   outColor.x += value;\n" +
            "   outColor.y += value;\n" +
            "   outColor.z += value;\n\n" +
            "   // make the output color\n" +
            "   gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);\n" +
            g_fragmentShaderFooter
        );
    }

    function buildFragmentShader_equation_curves () {
        return createFragmentShader(gl,
            g_fragmentShaderHeader +
            "   // Get our control points\n" +
            "   // The center of each pixel is technically where the pixel color is.\n" +
            "   // Doesn't really matter for NEAREST sampling, but doing it anyhow\n" +
            "   vec4 A = texture2D(uSampler, vec2(0.25,0.25));\n" +
            "   vec4 B = texture2D(uSampler, vec2(0.75,0.25));\n" +
            "   vec4 C = texture2D(uSampler, vec2(0.75,0.75));\n\n" +
            "   // Evaluate the quadratic bezier curves at time t.\n" +
            "   // Paralelized since each one is in a different color channel.\n" +
            "   float t = vTextureCoord.x;\n" +
            "   vec4 curveValues = A * (1.0-t) * (1.0-t) + B * 2.0 * t * (1.0 - t) + C * t * t;\n\n" +
            "   // use the derivative of the quadratic bezier function to calculate the slope at this point\n" +
            "   vec4 slope = 2.0 * (B + A * (-1.0 + t) - 2.0 * B * t + C * t);\n\n" +
            "   // Use the slope to get the gradient, and use the gradient to get a distance estimation to the curves\n" +
            "   // R,G,B curves add 1.0 to their color channels respectively\n" +
            "   vec3 outColor;\n" +
            "   outColor.x = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.x) / length(vec2(slope.x, -1.0)));\n" +
            "   outColor.y = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.y) / length(vec2(slope.y, -1.0)));\n" +
            "   outColor.z = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.z) / length(vec2(slope.z, -1.0)));\n\n" +
            "   // alpha curve adds 1.0 to each color channel\n" +
            "   float value = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.w) / length(vec2(slope.w, -1.0)));\n" +
            "   outColor.x += value;\n" +
            "   outColor.y += value;\n" +
            "   outColor.z += value;\n" +
            "   // make the output color\n" +
            "   gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);\n" +
            g_fragmentShaderFooter
        );
    }

    function buildFragmentShader () {
        var samplingMode = document.getElementById("SamplingMode").value;
        var renderMode = document.getElementById("RenderMode").value;

        if (renderMode == "texture")
        {
            return buildFragmentShader_texture();
        }

        if (samplingMode == "bilinear")
        {
            if (renderMode == "halfspace")
                return buildFragmentShader_halfspace(true);
            else if (renderMode == "curves")
                return buildFragmentShader_bilinear_curves();
        }
        else if (samplingMode == "nearest")
        {
            if (renderMode == "halfspace")
                return buildFragmentShader_halfspace(false);
            else if (renderMode == "curves")
                return buildFragmentShader_equation_curves();
        }

        alert("Could not find shader to generate");
        return null;
    }

    var FSshaderProgram;
    var CPShaderProgram;

    function initShaders() {
    	// make the full screen shader program
        var fragmentShader = buildFragmentShader();
        var vertexShader = getShader(gl, "shader-vs");

        FSshaderProgram = gl.createProgram();
        gl.attachShader(FSshaderProgram, vertexShader);
        gl.attachShader(FSshaderProgram, fragmentShader);
        gl.linkProgram(FSshaderProgram);

        if (!gl.getProgramParameter(FSshaderProgram, gl.LINK_STATUS))
            alert("Could not initialise FS shader");

        gl.useProgram(FSshaderProgram);

        FSshaderProgram.vertexPositionAttribute = gl.getAttribLocation(FSshaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(FSshaderProgram.vertexPositionAttribute);

        FSshaderProgram.textureCoordinateAttribute = gl.getAttribLocation(FSshaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(FSshaderProgram.textureCoordinateAttribute);

        FSshaderProgram.samplerUniform = gl.getUniformLocation(FSshaderProgram, "uSampler");

        // make the control point shader program
        fragmentShader = getShader(gl, "shader-fs-cp");
        vertexShader = getShader(gl, "shader-vs-cp");

        CPshaderProgram = gl.createProgram();
        gl.attachShader(CPshaderProgram, vertexShader);
        gl.attachShader(CPshaderProgram, fragmentShader);
        gl.linkProgram(CPshaderProgram);

        if (!gl.getProgramParameter(CPshaderProgram, gl.LINK_STATUS))
            alert("Could not initialise CP shader");        

		gl.useProgram(CPshaderProgram);

        CPshaderProgram.vertexPositionAttribute = gl.getAttribLocation(CPshaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(CPshaderProgram.vertexPositionAttribute);

        CPshaderProgram.uOffsetLocation = gl.getUniformLocation(CPshaderProgram, "uOffset");
        gl.uniform2f(CPshaderProgram.uOffsetLocation, 0, 0);

        CPshaderProgram.uColorLocation = gl.getUniformLocation(CPshaderProgram, "uColor");
        gl.uniform3f(CPshaderProgram.uColorLocation, 0, 0, 0);
    }

    function createTexture(byteArrayWithRGBAData, width, height) {
    	var filter = (document.getElementById("SamplingMode").value == "bilinear")
    		? gl.LINEAR
    		: gl.NEAREST;

        var data = new Uint8Array(byteArrayWithRGBAData);
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    var bezierTexture;
    var g_controlPoints = [
    	[128,   0,  50, 190],
    	[  0, 255,   0,   0],
    	[190,  64, 255,  75]
	];

    function initTexture() {
    	// Get the control point data from our sliders
        for (i = 0; i <= g_settings.m_desiredTextureSizeY; ++i)
        {
        	g_controlPoints[i] = [
				document.getElementById("R"+i.toString()).value * 2.55,
				document.getElementById("G"+i.toString()).value * 2.55,
				document.getElementById("B"+i.toString()).value * 2.55,
				document.getElementById("A"+i.toString()).value * 2.55,
			];
        }

		// make our texture data
        var textureData = new Array;
        for (i = 0; i < g_settings.m_desiredTextureSizeY; ++i)
        {
            textureData.push(g_controlPoints[i][0]);
            textureData.push(g_controlPoints[i][1]);
            textureData.push(g_controlPoints[i][2]);
            textureData.push(g_controlPoints[i][3]);
            textureData.push(g_controlPoints[i+1][0]);
            textureData.push(g_controlPoints[i+1][1]);
            textureData.push(g_controlPoints[i+1][2]);
            textureData.push(g_controlPoints[i+1][3]);
        }

        // fill in the rest of the texture we had to allocate with opaque black.
        // we have to round up to the next even numbered texture size, which can cause this needing to happen.
        for (i = g_settings.m_desiredTextureSizeY; i < g_settings.m_actualTextureSizeY; ++i)
        {
        	textureData = textureData.concat([1,1,1,1]);
            textureData = textureData.concat([1,1,1,1]);
        }

        // create the texture
        bezierTexture = createTexture(
            textureData,
            g_settings.m_actualTextureSizeX, g_settings.m_actualTextureSizeY
        );
    }

    var screenQuadBuffer;
    var screenQuadTextureCoordinateBuffer;
    var controlPointBuffer;

    function initBuffers() {
    	// make the full screen quad vertex buffer
        screenQuadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,
             1.0, -1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0,  1.0,
            -1.0,  1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        screenQuadBuffer.itemSize = 2;
        screenQuadBuffer.numItems = 6;

        // make the full screen quad texture coordinate buffer
        screenQuadTextureCoordinateBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        vertices = [
            0, 0,
            1, 0,
            1, 1,
            0, 0,
            1, 1,
            0, 1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        screenQuadTextureCoordinateBuffer.itemSize = 2;
        screenQuadTextureCoordinateBuffer.numItems = 6;

        // make the control point quad vertex buffer
        controlPointBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, controlPointBuffer);
        var size = 0.025;
        vertices = [
            // Front face
            -size, -size,
             size, -size,
             size,  size,
            -size, -size,
             size,  size,
            -size,  size,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        controlPointBuffer.itemSize = 2;
        controlPointBuffer.numItems = 6;        
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // draw the full screen quad
		gl.useProgram(FSshaderProgram);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, screenQuadBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        gl.vertexAttribPointer(FSshaderProgram.textureCoordinateAttribute, screenQuadTextureCoordinateBuffer.itemSize, gl.FLOAT, false, 0, 0);        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bezierTexture);
        gl.uniform1i(FSshaderProgram.samplerUniform, 0);
        gl.drawArrays(gl.TRIANGLES,0,screenQuadBuffer.numItems);

	    // draw the control points if we aren't in texture rendering mode
        if (document.getElementById("RenderMode").value != "texture")
        {
	        gl.useProgram(CPshaderProgram);        
	        gl.bindBuffer(gl.ARRAY_BUFFER, controlPointBuffer);
	        gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, controlPointBuffer.itemSize, gl.FLOAT, false, 0, 0);

			// Draw Red curve control points
	        for (i = 0; i <= g_settings.m_desiredTextureSizeY; ++i)
	        {
	        	gl.uniform3f(CPshaderProgram.uColorLocation, 1, 0, 0);
	        	gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / (g_settings.m_desiredTextureSizeY)) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][0]/255.0 - 0.5));
	        	gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
	        }

			// Draw Green curve control points
	        for (i = 0; i <= g_settings.m_desiredTextureSizeY; ++i)
	        {
	        	gl.uniform3f(CPshaderProgram.uColorLocation, 0, 1, 0);
	        	gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / (g_settings.m_desiredTextureSizeY)) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][1]/255.0 - 0.5));
	        	gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
	        }        

			// Draw Blue curve control points
	        for (i = 0; i <= g_settings.m_desiredTextureSizeY; ++i)
	        {
	        	gl.uniform3f(CPshaderProgram.uColorLocation, 0, 0, 1);
	        	gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / (g_settings.m_desiredTextureSizeY)) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][2]/255.0 - 0.5));
	        	gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
	        }           

			// Draw Alpha curve control points
	        for (i = 0; i <= g_settings.m_desiredTextureSizeY; ++i)
	        {
	        	gl.uniform3f(CPshaderProgram.uColorLocation, 1, 1, 1);
	        	gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / (g_settings.m_desiredTextureSizeY)) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][3]/255.0 - 0.5));
	        	gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
	        }            
		} 
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        g_frameCounter++;
    }

    function initSettings() {
    	// calculate the texture size we need
        g_settings.m_desiredTextureSizeX = 2;
        g_settings.m_desiredTextureSizeY = parseInt(document.getElementById("TextureSizeY").value);

        // round the texture size up to the next power of 2
        g_settings.m_actualTextureSizeX = nextPowerOfTwo(g_settings.m_desiredTextureSizeX);
        g_settings.m_actualTextureSizeY = nextPowerOfTwo(g_settings.m_desiredTextureSizeY);

        // create the control points
		document.getElementById("RedControlPoints").innerHTML = "";
		document.getElementById("GreenControlPoints").innerHTML = "";
		document.getElementById("BlueControlPoints").innerHTML = "";
		document.getElementById("AlphaControlPoints").innerHTML = "";
		for (i = 0; i <= g_settings.m_desiredTextureSizeY; ++i)
		{
			var value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][0] == 'undefined') ? 0 : g_controlPoints[i][0] / 2.55;
			document.getElementById("RedControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"R" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";
			value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][1] == 'undefined') ? 0 : g_controlPoints[i][1] / 2.55;
			document.getElementById("GreenControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"G" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";
			value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[2] == 'undefined') ? 0 : g_controlPoints[i][2] / 2.55;
			document.getElementById("BlueControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"B" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";
			value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][3] == 'undefined') ? 0 : g_controlPoints[i][3] / 2.55;
			document.getElementById("AlphaControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"A" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";
		}
    }

    function initGL() {
        var canvas = document.getElementById("webglcanvas");
        var canvassize = document.getElementById("CanvasSize").value;
        canvas.width = canvassize;
        canvas.height = canvassize;
        // details of options below here: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
        gl = WebGLUtils.setupWebGL(canvas, {alpha:true, depth: false, stencil: false, antialias: false, premultipliedAlpha:false, preserveDrawingBuffer: false});
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        initSettings();
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
    }

    function DoOnLoad() {
    	initGL();
    	setInterval(function(){ document.getElementById("fps").innerText = "FPS: " + g_frameCounter + " (" + Math.round(100 * 1000.0/g_frameCounter) / 100 + " ms)"; g_frameCounter = 0; }, 1000);
        tick();
    }

    function ResizeCanvas() {
    	initGL();
    }

    function OnChangeSettings()
    {
        initSettings();
        initShaders();
        initTexture();
    }

    /*
    TODO:
        * make the equation half space shader work. 
        * make the curve shaders work

        * choose X axis, then Y axis, and then curves per pixel and make the last one the order modifier
    	* choose order of curve (Y axis resolution)
    	* choose how many curves there are end to end (X axis resolution)
    	* somehow work in # of curves per 2x2 square (so could get 2 cubics from 1 read instead of 4 quadratics.  Could also get 1 5th order curve from 1 read!)
        * show text of what it's doing above, and the size of the texture.
        * show the size and layout of texture in fragment shader source comments
        * clean up and organize code?

        * make the "curves per texture sample" feature work
        * make the "Texture Size Y axis" feature work
        * make the "Texture Size X axis" feature work

        * test all variations of params, especially the weird (degenerate) cases like texture size Y axis of 1 making a lerp.

        * maybe combine the equation and texture code more.  basically textures just remove one layer of blending vs equations

        * make sure all render modes show shader source! (like... texture even!)
    */
</script>
</head>

<body onload="DoOnLoad()">
    <h1>GPU Efficient Texture Based Bezier Curve Evaluation</h1>
    <a href="index.html">Back to Index</a><br><br>
    <table>
	    <tr>
		    <td>
			    <table>
				    <tr>
				    	<td>Texture Size Y Axis (Order):</td>
				    	<td>
						    <select id="TextureSizeY" OnChange="OnChangeSettings();">
						    	<option value="1">1: Linear (Order 1)</option>
						    	<option value="2" selected="selected">2: Quadratic (Order 2)</option>
						    	<option value="3">3: Cubic (Order 3)</option>
						    	<option value="4">4: Quartic (Order 4)</option>
						    	<option value="5">5: Quintic (Order 5)</option>
						    	<option value="6">6: Sextic (Order 6)</option>
						    	<option value="7">7: Septic (Order 7)</option>
						    	<option value="8">8: Octic (Order 8)</option>
						    </select>	    	
				    	</td>
					</tr>		
				    <tr>
				    	<td>Texture Size X axis (# Curves):</td>
				    	<td>
						    <select id="TextureSizeX" OnChange="OnChangeSettings();">
						    	<option value="2">2: 1 curve  [T=0..1]</option>
						    	<option value="4">4: 2 curves [T=0..2]</option>
						    	<option value="6">6: 3 curves [T=0..3]</option>
						    	<option value="8">8: 4 curves [T=0..4]</option>
						    	<option value="10">10: 5 curves [T=0..5]</option>
						    </select>	    	
				    	</td>
					</tr>
                    <tr>
                        <td>Curves Per Pixel (Order Boost):</td>
                        <td>
                            <select id="CurvesPerPixel" OnChange="OnChangeSettings();">
                                <option value="4">4: +0 order [R] [G] [B] [A]</option>
                                <option value="2">2: +1 order [R&amp;G], [B&amp;A]</option>
                                <option value="1">1: +2 order [R&amp;G&amp;B&amp;A]</option>
                            </select>           
                        </td>
                    </tr>
				</table>
			</td>
			<td>
				<table>
					<tr>
					    <td>Sampling:</td>
					    <td>
						    <select id="SamplingMode" onChange="OnChangeSettings();">
						    	<option value="bilinear">Bilinear</option>
						    	<option value="nearest">Nearest (+2 Texture Reads)</option>
						    </select>
					    </td>
				    </tr>
				    <tr>
					    <td>Render:</td>
					    <td>
						    <select id="RenderMode" onChange="OnChangeSettings();">
						    	<option value="halfspace">HalfSpace</option>
						    	<option value="curves">Curves</option>
			                    <option value="texture">Texture</option>
						    </select>
						</td>
					</tr>
					<tr>
					    <td>Resolution:</td>
					    <td><select id="CanvasSize" onChange="ResizeCanvas();">
					    	<option value="250">250x250</option>
					    	<option value="500" selected="selected">500x500</option>
					    	<option value="1000">1000x1000</option>
					    </select>
					    </td>
				    </tr>
			    </table>
			</td>
		</tr>
	</table>
    <div id="fps">FPS: --</div>
    <table>
        <tr>
            <td valign="top">
                <canvas id="webglcanvas" style="border: none" width="500" height="500"></canvas>
            </td>
            <td valign="top" style="border:2px solid red">
                Red:<br>
                <span id="RedControlPoints"></span>
            </td>
            <td valign="top" style="border:2px solid green">
                Green:<br>
                <span id="GreenControlPoints"></span>
            </td>
            <td valign="top" style="border:2px solid blue">                
                Blue:<br>
                <span id="BlueControlPoints"></span>
            </td>
            <td valign="top" style="border:2px solid black">                
                Alpha:<br>
                <span id="AlphaControlPoints"></span>
            </td>
        </tr>
    </table>
	<a href="index.html">Back to Index</a><br><br>
    <b>Fragment Shader Source (GLSL):</b>
    <pre id="ShaderSource" style="border:1px solid black"></pre>
</body>

</html>