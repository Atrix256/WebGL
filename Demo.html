<!--
    WebGL initialization and basic utility code is based on the source code found here:
    http://learningwebgl.com/blog/?page_id=1217

    The rest was written by myself: Alan Wolfe  awolfe@blizzard.com
-->
<html>
<head>
<title>GPU Efficient Texture Based Bezier Curve Evaluation</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = vec4(aVertexPosition, 1.0, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>

<script id="shader-vs-cp" type="x-shader/x-vertex">
    attribute vec2 aVertexPosition;
    uniform vec2 uOffset;

    varying vec2 vPosition;

    void main(void) {
        gl_Position = vec4(aVertexPosition+uOffset, 1.0, 1.0);
        vPosition = aVertexPosition;
    }
</script>

<script id="shader-fs-cp" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec3 uColor;

    varying vec2 vPosition;

    void main(void) {
        if (length(vPosition) > 0.024)
            discard;
        gl_FragColor = vec4(uColor,1.0);   
    }
</script>

<script type="text/javascript">

    var gl;
    var g_frameCounter = 0;

    function nextPowerOfTwo(v) {
        v = v-1;
        v|=v>>1;
        v|=v>>2;
        v|=v>>4;
        v|=v>>8;
        v|=v>>16;
        return v+1;
    }

    function pascalsTriangle(n)
    {
        var ret = [1];
        for (i = 0; i < n; ++i)
            ret.push(ret[i] * (n - i) / (i + 1));
        return ret;
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript)
            return null;

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3)
                str += k.textContent;
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment")
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        else if (shaderScript.type == "x-shader/x-vertex")
            shader = gl.createShader(gl.VERTEX_SHADER);
        else
            return null;

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function createFragmentShader(gl, source) {
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    var g_settings = {};

    function GetNumUIControlPoints ()
    {
        return (g_settings.m_desiredTextureSizeY + g_settings.m_orderBoost) * (g_settings.m_desiredTextureSizeX/2);
    }

    var g_fragmentShaderHeader = 
        "#extension GL_OES_standard_derivatives : enable\n"+
        "precision mediump float;\n" + 
        "uniform sampler2D uSampler;\n" + 
        "varying vec2 vTextureCoord;\n\n" + 
        "void main(void) {\n";

    var g_fragmentShaderFooter = "}";

    function buildFragmentShader_texture () {
        var shaderSource = 
            g_fragmentShaderHeader +
            "   gl_FragColor = texture2D(uSampler, vTextureCoord);\n" + 
            g_fragmentShaderFooter;

        document.getElementById("ShaderSource").innerText = shaderSource;
        return createFragmentShader(gl,shaderSource);
    }

    function buildFragmentShader_visual (bilinear, curves) {
        var shaderSource = g_fragmentShaderHeader;

        // calculate how many texture samples there will be
        var textureSampleCount = bilinear ? g_settings.m_desiredTextureSizeY - 1 : g_settings.m_desiredTextureSizeY + 1;
        if (textureSampleCount < 1)
            textureSampleCount = 1;

        shaderSource += 
            "   // Calculate the powers of s and t that we will need.\n" +
            "   float t1 = vTextureCoord.x;\n";

        var powersNeeded = textureSampleCount;
        if (powersNeeded < g_settings.m_orderBoost + 1)
            powersNeeded = g_settings.m_orderBoost + 1;

        if (powersNeeded > 1)
        {
            shaderSource +=
                "   float s1 = (1.0 - t1);\n";

            for (i = 2; i < powersNeeded; ++i) 
            {
                shaderSource += "   float t" + i.toString() + " = t" + (i-1).toString() + " * t1;\n";
                shaderSource += "   float s" + i.toString() + " = s" + (i-1).toString() + " * s1;\n";
            }
        }
        shaderSource += "\n";

        if (bilinear)
        {
            shaderSource +=
                "   // Calculate our sample value.\n" + 
                "   // The center of each pixel is where the color is.\n"+
                "   float sample = 0.25 + t1 / 2.0;\n\n";

            // do the texture sample(s)
            if (textureSampleCount == 1)
            {
                shaderSource += "   // Do the texture sample\n";
                shaderSource += "   vec4 curveValues = texture2D(uSampler, vec2(sample));\n\n";
            }
            else
            {
                shaderSource += "   // Do the texture samples\n";
                for (i = 1; i <= textureSampleCount; ++i)
                {
                    shaderSource += "   vec4 P" + i.toString() + " = texture2D(uSampler, vec2(sample, sample / " + (g_settings.m_actualTextureSizeY / 2).toFixed(1) + " + " + (i-1).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n";
                }
                shaderSource += "\n";
            }
        }
        else
        {
            shaderSource += "   // Do the texture samples\n";
            for (i = 1; i < textureSampleCount; ++i)
            {
                shaderSource += "   vec4 P" + i.toString() + " = texture2D(uSampler, vec2(1.0 / " + (g_settings.m_actualTextureSizeX*2).toFixed(1) + ", " + (i-1).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n";
            }
            // TODO: that hard coded 3 / N is wrong.  it shouldn't be 3, what should it be? need to change it if having multiple textures in a row

            shaderSource += "   vec4 P" + textureSampleCount.toString() + " = texture2D(uSampler, vec2(3.0 / " + (g_settings.m_actualTextureSizeX*2).toFixed(1) + ", " + (textureSampleCount-2).toFixed(1) + " / " + g_settings.m_actualTextureSizeY.toFixed(1) + "));\n\n";
        }

        // combine texture samples if we have multiple.  Otherwise we've already done all the work we need to do
        if (textureSampleCount > 1)
        {
            // Use the binomial theorem to generate the Nth order bezier curve function
            shaderSource += 
                "   // Calculate the desired bezier curve by putting the points we have through the appropriate bezier curve equation.\n";
            coefficients = pascalsTriangle(textureSampleCount-1);
            shaderSource += "   vec4 curveValues = \n";
            for (i = 1; i <= textureSampleCount; ++i)
            {
                shaderSource += "      P" + i.toString() + " * " + coefficients[i-1].toFixed(1);
                if (i > 1)
                    shaderSource += " * t" + (i-1).toString();

                var j = textureSampleCount - i + 1;
                if (j > 1)
                    shaderSource += " * s" + (j-1).toString();

                if ( i < textureSampleCount)
                    shaderSource += " +\n";
                else
                    shaderSource += ";\n\n";
            }
        }

        // combine color channels for order boost
        if (g_settings.m_orderBoost == 1) {
            shaderSource +=
                "   // Combine resulting pixels for +1 order boost\n" +
                "   curveValues.x = \n" +
                "       curveValues.x * 1.0 * s1 +\n" +
                "       curveValues.y * 1.0 * t1;\n" +
                "   curveValues.y = \n" +
                "       curveValues.z * 1.0 * s1 +\n" +
                "       curveValues.w * 1.0 * t1;\n\n";
        }
        else if (g_settings.m_orderBoost == 3) {
            shaderSource +=
                "   // Combine resulting pixels for +2 order boost\n" +
                "   curveValues.x = \n" +
                "       curveValues.x * 1.0 * s3 +\n" +
                "       curveValues.y * 3.0 * t1 * s2 +\n" +
                "       curveValues.z * 3.0 * t2 * s1 +\n" +
                "       curveValues.w * 1.0 * t3;\n\n";
        }

       if (curves) {
            shaderSource +=
                "   // Calculate slope using dfdx so we can use the gradient to aproximate distance\n" +
                "   vec4 slope = dFdx(curveValues) / dFdx(vTextureCoord.x);\n\n";
        }

        shaderSource +=
            "   // R,G,B curves add to their color channels respectively, alpha adds to all.\n" + 
            "   vec3 outColor;\n";

		if (curves) {
			shaderSource +=
            	"   outColor.x = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.x) / length(vec2(slope.x, -1.0)));\n";

            if (g_settings.m_orderBoost < 3)
            {
                shaderSource +=
                	"   outColor.y = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.y) / length(vec2(slope.y, -1.0)));\n";

                if (g_settings.m_orderBoost < 1)
                {
                    shaderSource +=
                    	"   outColor.z = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.z) / length(vec2(slope.z, -1.0)));\n" +
                    	"   float v = smoothstep(0.01,0.0,abs(vTextureCoord.y - curveValues.w) / length(vec2(slope.w, -1.0)));\n" +
                    	"   outColor.x += v;\n" +
                    	"   outColor.y += v;\n" +
                    	"   outColor.z += v;\n";
                }
                else
                {
                    shaderSource +=
                        "   outColor.z = 0.0;\n";
                }
            }
            else
            {
                shaderSource +=
                    "   outColor.y = 0.0;\n" +
                    "   outColor.z = 0.0;\n";
            }  	
		}
		else {
	        shaderSource += 
	            "   outColor.x = step(vTextureCoord.y, curveValues.x) * 0.5;\n";

            if (g_settings.m_orderBoost < 3)
            {
                shaderSource += 
    	            "   outColor.y = step(vTextureCoord.y, curveValues.y) * 0.5;\n";

                if (g_settings.m_orderBoost < 1)
                {
                    shaderSource +=
        	            "   outColor.z = step(vTextureCoord.y, curveValues.z) * 0.5;\n" +
        	            "   float v = step(vTextureCoord.y, curveValues.w) * 0.5;\n" +
        	            "   outColor.x += v;\n" +
        	            "   outColor.y += v;\n" +
        	            "   outColor.z += v;\n";
                }
                else
                {
                    shaderSource +=
                        "   outColor.z = 0.0;\n";
                }
            }
            else
            {
                shaderSource +=
                    "   outColor.y = 0.0;\n" +
                    "   outColor.z = 0.0;\n";
            }
		}

        shaderSource += 
            "\n" +
            "   // make the output color\n" +
            "   gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);\n" +
            g_fragmentShaderFooter;

        document.getElementById("ShaderSource").innerText = shaderSource;
        return createFragmentShader(gl,shaderSource);
    }

    function buildFragmentShader () {
        var samplingMode = document.getElementById("SamplingMode").value;
        var renderMode = document.getElementById("RenderMode").value;

        if (renderMode == "texture")
            return buildFragmentShader_texture();

        var bilinear = (samplingMode == "bilinear");
        var curves = (renderMode == "curves");
        return buildFragmentShader_visual(bilinear, curves);

        alert("Could not find shader to generate");
        return null;
    }

    var FSshaderProgram;
    var CPShaderProgram;

    function initShaders() {
        // make the full screen shader program
        var fragmentShader = buildFragmentShader();
        var vertexShader = getShader(gl, "shader-vs");

        FSshaderProgram = gl.createProgram();
        gl.attachShader(FSshaderProgram, vertexShader);
        gl.attachShader(FSshaderProgram, fragmentShader);
        gl.linkProgram(FSshaderProgram);

        if (!gl.getProgramParameter(FSshaderProgram, gl.LINK_STATUS))
            alert("Could not initialise FS shader");

        gl.useProgram(FSshaderProgram);

        FSshaderProgram.vertexPositionAttribute = gl.getAttribLocation(FSshaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(FSshaderProgram.vertexPositionAttribute);

        FSshaderProgram.textureCoordinateAttribute = gl.getAttribLocation(FSshaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(FSshaderProgram.textureCoordinateAttribute);

        FSshaderProgram.samplerUniform = gl.getUniformLocation(FSshaderProgram, "uSampler");

        // make the control point shader program
        fragmentShader = getShader(gl, "shader-fs-cp");
        vertexShader = getShader(gl, "shader-vs-cp");

        CPshaderProgram = gl.createProgram();
        gl.attachShader(CPshaderProgram, vertexShader);
        gl.attachShader(CPshaderProgram, fragmentShader);
        gl.linkProgram(CPshaderProgram);

        if (!gl.getProgramParameter(CPshaderProgram, gl.LINK_STATUS))
            alert("Could not initialise CP shader");        

        gl.useProgram(CPshaderProgram);

        CPshaderProgram.vertexPositionAttribute = gl.getAttribLocation(CPshaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(CPshaderProgram.vertexPositionAttribute);

        CPshaderProgram.uOffsetLocation = gl.getUniformLocation(CPshaderProgram, "uOffset");
        gl.uniform2f(CPshaderProgram.uOffsetLocation, 0, 0);

        CPshaderProgram.uColorLocation = gl.getUniformLocation(CPshaderProgram, "uColor");
        gl.uniform3f(CPshaderProgram.uColorLocation, 0, 0, 0);
    }

    function createTexture(byteArrayWithRGBAData, width, height) {
        var filter = (document.getElementById("SamplingMode").value == "bilinear")
            ? gl.LINEAR
            : gl.NEAREST;

        var data = new Uint8Array(byteArrayWithRGBAData);
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    var bezierTexture;
    var g_controlPoints = [
        [128,   0,  50, 190],
        [  0, 255,   0,   0],
        [190,  64, 255,  75]
    ];

    function initTexture() {
        // Get the control point data from our sliders
        for (i = 0; i <= GetNumUIControlPoints(); ++i)
        {
            g_controlPoints[i] = [
                document.getElementById("R"+i.toString()).value * 2.55,
                document.getElementById("G"+i.toString()).value * 2.55,
                document.getElementById("B"+i.toString()).value * 2.55,
                document.getElementById("A"+i.toString()).value * 2.55,
            ];
        }

        // make our texture data
        var textureData = new Array;

        if (g_settings.m_orderBoost == 0)
        {
            for (i = 0; i < g_settings.m_desiredTextureSizeY; ++i)
            {
                textureData.push(g_controlPoints[i][0]);
                textureData.push(g_controlPoints[i][1]);
                textureData.push(g_controlPoints[i][2]);
                textureData.push(g_controlPoints[i][3]);
                textureData.push(g_controlPoints[i+1][0]);
                textureData.push(g_controlPoints[i+1][1]);
                textureData.push(g_controlPoints[i+1][2]);
                textureData.push(g_controlPoints[i+1][3]);
            }
        }
        else if (g_settings.m_orderBoost == 1)
        {
            for (i = 0; i < g_settings.m_desiredTextureSizeY; ++i)
            {
                textureData.push(g_controlPoints[i  ][0]);
                textureData.push(g_controlPoints[i+1][0]);
                textureData.push(g_controlPoints[i  ][1]);
                textureData.push(g_controlPoints[i+1][1]);
                textureData.push(g_controlPoints[i+1][0]);
                textureData.push(g_controlPoints[i+2][0]);
                textureData.push(g_controlPoints[i+1][1]);
                textureData.push(g_controlPoints[i+2][1]);
            }
        }
        else if (g_settings.m_orderBoost == 3)
        {
            for (i = 0; i < g_settings.m_desiredTextureSizeY; ++i)
            {
                textureData.push(g_controlPoints[i  ][0]);
                textureData.push(g_controlPoints[i+1][0]);
                textureData.push(g_controlPoints[i+2][0]);
                textureData.push(g_controlPoints[i+3][0]);
                textureData.push(g_controlPoints[i+1][0]);
                textureData.push(g_controlPoints[i+2][0]);
                textureData.push(g_controlPoints[i+3][0]);
                textureData.push(g_controlPoints[i+4][0]);
            }            
        }

        // fill in the rest of the texture we had to allocate with opaque black.
        // we have to round up to the next even numbered texture size, which can cause this needing to happen.
        for (i = g_settings.m_desiredTextureSizeY; i < g_settings.m_actualTextureSizeY; ++i)
        {
            textureData = textureData.concat([1,1,1,1]);
            textureData = textureData.concat([1,1,1,1]);
        }

        // create the texture
        bezierTexture = createTexture(
            textureData,
            g_settings.m_actualTextureSizeX, g_settings.m_actualTextureSizeY
        );
    }

    var screenQuadBuffer;
    var screenQuadTextureCoordinateBuffer;
    var controlPointBuffer;

    function initBuffers() {
        // make the full screen quad vertex buffer
        screenQuadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,
             1.0, -1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0,  1.0,
            -1.0,  1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        screenQuadBuffer.itemSize = 2;
        screenQuadBuffer.numItems = 6;

        // make the full screen quad texture coordinate buffer
        screenQuadTextureCoordinateBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        vertices = [
            0, 0,
            1, 0,
            1, 1,
            0, 0,
            1, 1,
            0, 1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        screenQuadTextureCoordinateBuffer.itemSize = 2;
        screenQuadTextureCoordinateBuffer.numItems = 6;

        // make the control point quad vertex buffer
        controlPointBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, controlPointBuffer);
        var size = 0.025;
        vertices = [
            // Front face
            -size, -size,
             size, -size,
             size,  size,
            -size, -size,
             size,  size,
            -size,  size,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        controlPointBuffer.itemSize = 2;
        controlPointBuffer.numItems = 6;        
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // draw the full screen quad
        gl.useProgram(FSshaderProgram);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, screenQuadBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadTextureCoordinateBuffer);
        gl.vertexAttribPointer(FSshaderProgram.textureCoordinateAttribute, screenQuadTextureCoordinateBuffer.itemSize, gl.FLOAT, false, 0, 0);        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bezierTexture);
        gl.uniform1i(FSshaderProgram.samplerUniform, 0);
        gl.drawArrays(gl.TRIANGLES,0,screenQuadBuffer.numItems);

        // draw the control points if we aren't in texture rendering mode
        if (document.getElementById("RenderMode").value != "texture")
        {
            gl.useProgram(CPshaderProgram);        
            gl.bindBuffer(gl.ARRAY_BUFFER, controlPointBuffer);
            gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, controlPointBuffer.itemSize, gl.FLOAT, false, 0, 0);

            // Draw Red curve control points
            for (i = 0; i <= GetNumUIControlPoints(); ++i)
            {
                gl.uniform3f(CPshaderProgram.uColorLocation, 1, 0, 0);
                gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / GetNumUIControlPoints()) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][0]/255.0 - 0.5));
                gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
            }

            if (g_settings.m_orderBoost < 3)
            {
                // Draw Green curve control points
                for (i = 0; i <= GetNumUIControlPoints(); ++i)
                {
                    gl.uniform3f(CPshaderProgram.uColorLocation, 0, 1, 0);
                    gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / GetNumUIControlPoints()) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][1]/255.0 - 0.5));
                    gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
                } 

                if (g_settings.m_orderBoost < 1)
                {
                    // Draw Blue curve control points
                    for (i = 0; i <= GetNumUIControlPoints(); ++i)
                    {
                        gl.uniform3f(CPshaderProgram.uColorLocation, 0, 0, 1);
                        gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / GetNumUIControlPoints()) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][2]/255.0 - 0.5));
                        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
                    }           

                    // Draw Alpha curve control points
                    for (i = 0; i <= GetNumUIControlPoints(); ++i)
                    {
                        gl.uniform3f(CPshaderProgram.uColorLocation, 1, 1, 1);
                        gl.uniform2f(CPshaderProgram.uOffsetLocation, (i / GetNumUIControlPoints()) * 2.0 - 1.0, 2.0 * (g_controlPoints[i][3]/255.0 - 0.5));
                        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
                    } 
                }
            }    
        } 
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        g_frameCounter++;
    }

    function initSettings() {
        // calculate the texture size we need
        g_settings.m_desiredTextureSizeX = parseInt(document.getElementById("TextureSizeX").value);
        g_settings.m_desiredTextureSizeY = parseInt(document.getElementById("TextureSizeY").value);

        // round the texture size up to the next power of 2
        g_settings.m_actualTextureSizeX = nextPowerOfTwo(g_settings.m_desiredTextureSizeX);
        g_settings.m_actualTextureSizeY = nextPowerOfTwo(g_settings.m_desiredTextureSizeY);

        // other settings
        g_settings.m_orderBoost = parseInt(document.getElementById("OrderBoost").value);

        // create the control points
        document.getElementById("RedControlPoints").innerHTML = "";
        document.getElementById("GreenControlPoints").innerHTML = "";
        document.getElementById("BlueControlPoints").innerHTML = "";
        document.getElementById("AlphaControlPoints").innerHTML = "";
        for (i = 0; i <= GetNumUIControlPoints(); ++i)
        {
            var value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][0] == 'undefined') ? 0 : g_controlPoints[i][0] / 2.55;
            document.getElementById("RedControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"R" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";

            value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][1] == 'undefined') ? 0 : g_controlPoints[i][1] / 2.55;
            document.getElementById("GreenControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"G" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";

            value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[2] == 'undefined') ? 0 : g_controlPoints[i][2] / 2.55;
            document.getElementById("BlueControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"B" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";
            value = (typeof g_controlPoints[i] == 'undefined' || typeof g_controlPoints[i][3] == 'undefined') ? 0 : g_controlPoints[i][3] / 2.55;
            document.getElementById("AlphaControlPoints").innerHTML += (i+1).toString() + ":<input type=\"range\" min=\"0\" max=\"100\" id=\"A" + i.toString() + "\" onInput=\"initTexture();\" onChange=\"initTexture();\" value=\"" + value + "\"/><br/>";
        }

        document.getElementById("GreenControlPointsContainer").style.visibility = (g_settings.m_orderBoost > 1) ? "hidden" : "visible";
        document.getElementById("BlueControlPointsContainer").style.visibility = (g_settings.m_orderBoost > 0) ? "hidden" : "visible";
        document.getElementById("AlphaControlPointsContainer").style.visibility = (g_settings.m_orderBoost > 0) ? "hidden" : "visible";
    }


    function initGL() {
        var canvas = document.getElementById("webglcanvas");
        var canvassize = document.getElementById("CanvasSize").value;
        canvas.width = canvassize;
        canvas.height = canvassize;
        // details of options below here: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
        gl = WebGLUtils.setupWebGL(canvas, {alpha:true, depth: false, stencil: false, antialias: false, premultipliedAlpha:false, preserveDrawingBuffer: false});

        gl.getExtension("OES_standard_derivatives");

        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        initSettings();
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
    }

    function DoOnLoad() {
        initGL();
        setInterval(function(){ document.getElementById("fps").innerText = "FPS: " + g_frameCounter + " (" + Math.round(100 * 1000.0/g_frameCounter) / 100 + " ms)"; g_frameCounter = 0; }, 1000);
        tick();
    }

    function ResizeCanvas() {
        initGL();
    }

    function OnChangeSettings()
    {
        initSettings();
        initShaders();
        initTexture();
    }

    function SetCPs (color, value)
    {
        for (i = 0; i <= GetNumUIControlPoints(); ++i)
            document.getElementById(color+i.toString()).value = value;
        initTexture();
    }

    function SetCPsRandom (color)
    {
        for (i = 0; i <= GetNumUIControlPoints(); ++i)
            document.getElementById(color+i.toString()).value = Math.random() * 100;
        initTexture();
    }

    /*
    TODO:
        * make X axis setting work

        * show text of what it's doing above, and the size of the texture involved
        * show the size and layout of texture in fragment shader source comments
        * clean up and organize code. make bracket spacing (newline or not) consistent. make functions start with capital letter.
        
        * test all variations of params, especially the weird (degenerate) cases like texture size Y axis of 1 making a lerp.

        * make a "zero" (clear?), a "one" and "random" button under each set of control point sliders

        * fix the index page to point to this page and remove the other pages
        * THEN: c++ opengl version, OR webGL vector graphics on geometry
    */
</script>
</head>

<body onload="DoOnLoad()">
    <h1>GPU Efficient Texture Based Bezier Curve Evaluation</h1>
    <a href="index.html">Back to Index</a><br><br>
    <table>
        <tr>
            <td>
                <table>
                    <tr>
                        <td>Texture Size Y Axis (Order):</td>
                        <td>
                            <select id="TextureSizeY" OnChange="OnChangeSettings();">
                                <option value="1">1: Linear (Order 1)</option>
                                <option value="2" selected="selected">2: Quadratic (Order 2)</option>
                                <option value="3">3: Cubic (Order 3)</option>
                                <option value="4">4: Quartic (Order 4)</option>
                                <option value="5">5: Quintic (Order 5)</option>
                                <option value="6">6: Sextic (Order 6)</option>
                                <option value="7">7: Septic (Order 7)</option>
                                <option value="8">8: Octic (Order 8)</option>
                            </select>            
                        </td>
                    </tr>        
                    <tr>
                        <td>Texture Size X axis (# Curves):</td>
                        <td>
                            <select id="TextureSizeX" OnChange="OnChangeSettings();">
                                <option value="2">2: 1 curve  [T=0..1]</option>
                                <option value="4">4: 2 curves [T=0..2]</option>
                                <option value="6">6: 3 curves [T=0..3]</option>
                                <option value="8">8: 4 curves [T=0..4]</option>
                                <option value="10">10: 5 curves [T=0..5]</option>
                            </select>            
                        </td>
                    </tr>
                    <tr>
                        <td>Curves Per Pixel (Order Boost):</td>
                        <td>
                            <select id="OrderBoost" OnChange="OnChangeSettings();">
                                <option value="0">4: +0 order [R] [G] [B] [A]</option>
                                <option value="1">2: +1 order [R&amp;G], [B&amp;A]</option>
                                <option value="3">1: +3 order [R&amp;G&amp;B&amp;A]</option>
                            </select>           
                        </td>
                    </tr>
                </table>
            </td>
            <td>
                <table>
                    <tr>
                        <td>Sampling:</td>
                        <td>
                            <select id="SamplingMode" onChange="OnChangeSettings();">
                                <option value="bilinear">Bilinear</option>
                                <option value="nearest">Nearest (+2 Texture Reads)</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>Render:</td>
                        <td>
                            <select id="RenderMode" onChange="OnChangeSettings();">
                                <option value="halfspace">HalfSpace</option>
                                <option value="curves">Curves (dFdx for gradient distance)</option>
                                <option value="texture">Texture</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>Resolution:</td>
                        <td><select id="CanvasSize" onChange="ResizeCanvas();">
                            <option value="250">250x250</option>
                            <option value="500" selected="selected">500x500</option>
                            <option value="1000">1000x1000</option>
                        </select>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
    <div id="fps">FPS: --</div>
    <table>
        <tr>
            <td valign="top">
                <canvas id="webglcanvas" style="border: none" width="500" height="500"></canvas>
            </td>
            <td valign="top" style="border:2px solid red" id="RedControlPointsContainer">
                Red:<br>
                <span id="RedControlPoints"></span>
                <input type="button" onClick="SetCPs('R',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('R',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('R')" value="Random"/>
            </td>
            <td valign="top" style="border:2px solid green" id="GreenControlPointsContainer">
                Green:<br>
                <span id="GreenControlPoints"></span>
                <input type="button" onClick="SetCPs('G',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('G',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('G')" value="Random"/>
            </td>
            <td valign="top" style="border:2px solid blue" id="BlueControlPointsContainer">                
                Blue:<br>
                <span id="BlueControlPoints"></span>
                <input type="button" onClick="SetCPs('B',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('B',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('B')" value="Random"/>
            </td>
            <td valign="top" style="border:2px solid black" id="AlphaControlPointsContainer">                
                Alpha:<br>
                <span id="AlphaControlPoints"></span>
                <input type="button" onClick="SetCPs('A',0)" value="Zero"/>
                <input type="button" onClick="SetCPs('A',100)" value="One"/>
                <input type="button" onClick="SetCPsRandom('A')" value="Random"/>
            </td>
        </tr>
    </table>
    <a href="index.html">Back to Index</a><br><br>
    <b>Fragment Shader Source (GLSL):</b>
    <pre id="ShaderSource" style="border:1px solid black"></pre>
</body>

</html>