<!--
	WebGL initialization and basic utility code is based on the source code found here:
	http://learningwebgl.com/blog/?page_id=1217

	The rest was written by myself: Alan Wolfe  awolfe@blizzard.com
-->
<html>
<head>
<title>Cubic Bezier Curve</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs-bilinear-halfspace" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D uSampler;
    uniform vec2 uResolution;

    void main(void) {
        // Calculate normalized coordinates: 0 to 1 on each axis.
        vec2 normCoord = vec2(gl_FragCoord.x / uResolution.x, gl_FragCoord.y / uResolution.y);

        // Calculate our sample value.
        // The center of each pixel is where the value starts, not the edge, so our interpolation
        // goes from 0.25 -> 0.75, not from 0 to 1.
        float sample = 0.25 + normCoord.x / 2.0;

        // Evaluate the curve, using bilinear filtering to do bilinear interpolation to calculate our curve point.
        // note that since our texture is double wide on X axis, we need to divide by 2 to get the first sample
        // and add 0.5 to that to get the second sample.
        // we have to manually interpolate between the two quadratic curves made with bilinear filtering
        // since webgl doesn't support volumetric textures. Else we could do this with trilinear sampling!
        vec4 curveValuesA = texture2D(uSampler, vec2(sample/2.0,sample));
        vec4 curveValuesB = texture2D(uSampler, vec2(sample/2.0 + 0.5,sample));
        vec4 curveValues = mix(curveValuesA, curveValuesB, normCoord.x);

        // R,G,B curves add 0.5 to their color channels respectively
		vec3 outColor;
        outColor.x = step(normCoord.y, curveValues.x) * 0.5;
        outColor.y = step(normCoord.y, curveValues.y) * 0.5;
        outColor.z = step(normCoord.y, curveValues.z) * 0.5;

        // alpha curve adds 0.5 to each color channel
        float v = step(normCoord.y, curveValues.w) * 0.5;
        outColor.x += v;
        outColor.y += v;
        outColor.z += v;

        // make the output color
        gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);
    }
</script>

<script id="shader-fs-bilinear-curves" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D uSampler;
    uniform vec2 uResolution;

    void main(void) {
        // calculate normalized coordinates: 0 to 1 on each axis.
        vec2 normCoord = vec2(gl_FragCoord.x / uResolution.x, gl_FragCoord.y / uResolution.y);

        // Calculate our sample value.
        // The center of each pixel is where the value starts, not the edge, so our interpolation
        // goes from 0.25 -> 0.75, not from 0 to 1.
        float sample = 0.25 + normCoord.x / 2.0;

        // Evaluate the curve, using bilinear filtering to do bilinear interpolation to calculate our curve point.
        // note that since our texture is double wide on X axis, we need to divide by 2 to get the first sample
        // and add 0.5 to that to get the second sample.
        // we have to manually interpolate between the two quadratic curves made with bilinear filtering
        // since webgl doesn't support volumetric textures. Else we could do this with trilinear sampling!
        vec4 curveValuesA = texture2D(uSampler, vec2(sample/2.0,sample));
        vec4 curveValuesB = texture2D(uSampler, vec2(sample/2.0 + 0.5,sample));
        vec4 curveValues = mix(curveValuesA, curveValuesB, normCoord.x);

        // use finite differences to get an aproximation of the slope of the curve at this point
        float h = normCoord.x > 0.5 ? -0.01 : 0.01;
        curveValuesA = texture2D(uSampler, vec2(sample/2.0 + h,sample));
        curveValuesB = texture2D(uSampler, vec2(sample/2.0 + 0.5 + h,sample));
        vec4 curveValues2 = mix(curveValuesA, curveValuesB, normCoord.x);  
        vec4 slope = (curveValues2 - curveValues) / h; 

        // Use the slope to get the gradient, and use the gradient to get a distance estimation to the curves
        // R,G,B curves add 1.0 to their color channels respectively.
        vec3 outColor;
        outColor.x = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.x) / length(vec2(slope.x, -1.0)));
        outColor.y = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.y) / length(vec2(slope.y, -1.0)));
        outColor.z = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.z) / length(vec2(slope.z, -1.0)));

        // alpha curve adds 1.0 to each color channel
        float value = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.w) / length(vec2(slope.w, -1.0)));
        outColor.x += value;
        outColor.y += value;
        outColor.z += value;

        // make the output color
        gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);
    }
</script>

<script id="shader-fs-bilinear-texture" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D uSampler;
    uniform vec2 uResolution;

    void main(void) {
    	// show the texture
        vec2 normCoord = vec2(gl_FragCoord.x / uResolution.x, gl_FragCoord.y / uResolution.y);
        gl_FragColor = texture2D(uSampler, normCoord);
    }
</script>

<script id="shader-fs-equation-halfspace" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D uSampler;
    uniform vec2 uResolution;

    void main(void) {
        // calculate normalized coordinates: 0 to 1 on each axis.
        vec2 normCoord = vec2(gl_FragCoord.x / uResolution.x, gl_FragCoord.y / uResolution.y);

        // Get our control points
        // The center of each pixel is technically where the pixel color is.
        // Doesn't really matter for NEAREST sampling, but doing it anyhow
        // note that since our texture is double wide on X axis, we need to divide by 2 to get the first sample
        // and add 0.5 to that to get the second sample.
        vec4 A = texture2D(uSampler, vec2(0.25 / 2.0, 0.25));
        vec4 B = texture2D(uSampler, vec2(0.75 / 2.0, 0.25));
        vec4 C = texture2D(uSampler, vec2(0.75 / 2.0, 0.75));
        vec4 D = texture2D(uSampler, vec2(0.75 / 2.0 + 0.5, 0.75));

        // Evaluate the cubic bezier curves at time t.
        // Paralelized since each one is in a different color channel.
		float t = normCoord.x;
        float oneMinust = 1.0 - t;
        vec4 curveValues = A * oneMinust * oneMinust * oneMinust + B * 3.0 * t * oneMinust * oneMinust + C * 3.0 * t * t * oneMinust + D * t * t * t;

        // R,G,B curves add 0.5 to their color channels respectively
		vec3 outColor;
        outColor.x = step(normCoord.y, curveValues.x) * 0.5;
        outColor.y = step(normCoord.y, curveValues.y) * 0.5;
        outColor.z = step(normCoord.y, curveValues.z) * 0.5;

		// alpha curve adds 0.5 to each color channel
        float v = step(normCoord.y, curveValues.w) * 0.5;
        outColor.x += v;
        outColor.y += v;
        outColor.z += v;        

		// make the output color
        gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);
    }
</script>

<script id="shader-fs-equation-curves" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D uSampler;

    uniform vec2 uResolution;

    void main(void) {
        // calculate normalized coordinates: 0 to 1 on each axis.
        vec2 normCoord = vec2(gl_FragCoord.x / uResolution.x, gl_FragCoord.y / uResolution.y);

        // Get our control points
        // The center of each pixel is technically where the pixel color is.
        // Doesn't really matter for NEAREST sampling, but doing it anyhow
        // note that since our texture is double wide on X axis, we need to divide by 2 to get the first sample
        // and add 0.5 to that to get the second sample.
        vec4 A = texture2D(uSampler, vec2(0.25 / 2.0, 0.25));
        vec4 B = texture2D(uSampler, vec2(0.75 / 2.0, 0.25));
        vec4 C = texture2D(uSampler, vec2(0.75 / 2.0, 0.75));
        vec4 D = texture2D(uSampler, vec2(0.75 / 2.0 + 0.5, 0.75));

        // Evaluate the cubic bezier curves at time t.
        // Paralelized since each one is in a different color channel.
        float t = normCoord.x;
        float oneMinust = 1.0 - t;
        float tMinusOne = t - 1.0;
        vec4 curveValues = A * oneMinust * oneMinust * oneMinust + B * 3.0 * t * oneMinust * oneMinust + C * 3.0 * t * t * oneMinust + D * t * t * t;

        // use the derivative of the cubic bezier function to calculate the slope at this point
        vec4 slope = -3.0 * (A * tMinusOne * tMinusOne + B * (-3.0 * t * t + 4.0 * t - 1.0) + t * (3.0 * C * t - 2.0 * C - D * t));

		// Use the slope to get the gradient, and use the gradient to get a distance estimation to the curves
		// R,G,B curves add 1.0 to their color channels respectively
		vec3 outColor;
        outColor.x = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.x) / length(vec2(slope.x, -1.0)));
        outColor.y = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.y) / length(vec2(slope.y, -1.0)));
        outColor.z = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.z) / length(vec2(slope.z, -1.0)));

        // alpha curve adds 1.0 to each color channel
        float value = smoothstep(0.01,0.0,abs(normCoord.y - curveValues.w) / length(vec2(slope.w, -1.0)));
        outColor.x += value;
        outColor.y += value;
        outColor.z += value;

        // make the output color
        gl_FragColor = vec4(clamp(outColor,0.0,1.0), 1.0);        
    }
</script>

<script id="shader-fs-equation-texture" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D uSampler;
    uniform vec2 uResolution;

    void main(void) {
    	// show the texture
        vec2 normCoord = vec2(gl_FragCoord.x / uResolution.x, gl_FragCoord.y / uResolution.y);
        gl_FragColor = texture2D(uSampler, normCoord);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2 aVertexPosition;

    void main(void) {
        gl_Position = vec4(aVertexPosition, 1.0, 1.0);
    }
</script>

<script id="shader-vs-cp" type="x-shader/x-vertex">
    attribute vec2 aVertexPosition;
    uniform vec2 uOffset;

    void main(void) {
        gl_Position = vec4(aVertexPosition+uOffset, 1.0, 1.0);
    }
</script>

<script id="shader-fs-cp" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec3 uColor;

    void main(void) {
        gl_FragColor = vec4(uColor,1.0);   
    }
</script>

<script type="text/javascript">

    var gl;
    var g_frameCounter = 0;

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript)
            return null;

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3)
                str += k.textContent;
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment")
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        else if (shaderScript.type == "x-shader/x-vertex")
            shader = gl.createShader(gl.VERTEX_SHADER);
        else
            return null;

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    var FSshaderProgram;
    var CPShaderProgram;

    function initShaders() {
    	// make the full screen shader program
    	var evaluationMode = document.getElementById("EvaluationMode").value;
    	var renderMode = document.getElementById("RenderMode").value;

        var fragmentShader = getShader(gl, "shader-fs-"+evaluationMode+"-"+renderMode);
        var vertexShader = getShader(gl, "shader-vs");

        FSshaderProgram = gl.createProgram();
        gl.attachShader(FSshaderProgram, vertexShader);
        gl.attachShader(FSshaderProgram, fragmentShader);
        gl.linkProgram(FSshaderProgram);

        if (!gl.getProgramParameter(FSshaderProgram, gl.LINK_STATUS))
            alert("Could not initialise FS shader");

        gl.useProgram(FSshaderProgram);

        FSshaderProgram.vertexPositionAttribute = gl.getAttribLocation(FSshaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(FSshaderProgram.vertexPositionAttribute);
        FSshaderProgram.samplerUniform = gl.getUniformLocation(FSshaderProgram, "uSampler");

        var resolutionLocation = gl.getUniformLocation(FSshaderProgram, "uResolution");
        gl.uniform2f(resolutionLocation, gl.viewportWidth, gl.viewportHeight);

        // make the control point shader program
        fragmentShader = getShader(gl, "shader-fs-cp");
        vertexShader = getShader(gl, "shader-vs-cp");

        CPshaderProgram = gl.createProgram();
        gl.attachShader(CPshaderProgram, vertexShader);
        gl.attachShader(CPshaderProgram, fragmentShader);
        gl.linkProgram(CPshaderProgram);

        if (!gl.getProgramParameter(CPshaderProgram, gl.LINK_STATUS))
            alert("Could not initialise CP shader");        

		gl.useProgram(CPshaderProgram);

        CPshaderProgram.vertexPositionAttribute = gl.getAttribLocation(CPshaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(CPshaderProgram.vertexPositionAttribute);

        CPshaderProgram.uOffsetLocation = gl.getUniformLocation(CPshaderProgram, "uOffset");
        gl.uniform2f(CPshaderProgram.uOffsetLocation, 0, 0);

        CPshaderProgram.uColorLocation = gl.getUniformLocation(CPshaderProgram, "uColor");
        gl.uniform3f(CPshaderProgram.uColorLocation, 0, 0, 0);
    }

    function createTexture(byteArrayWithRGBAData, width, height) {
    	var filter = (document.getElementById("EvaluationMode").value == "bilinear")
    		? gl.LINEAR
    		: gl.NEAREST;

        var data = new Uint8Array(byteArrayWithRGBAData);
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    var bezierTexture;
    var pointA = [0,0,0,0];
    var pointB = [0,0,0,0];
    var pointC = [0,0,0,0];
    var pointD = [0,0,0,0];

    function initTexture() {
        pointA[0] = document.getElementById("R0").value * 2.55;
        pointA[1] = document.getElementById("G0").value * 2.55;
        pointA[2] = document.getElementById("B0").value * 2.55;
        pointA[3] = document.getElementById("A0").value * 2.55;

        pointB[0] = document.getElementById("R1").value * 2.55;
        pointB[1] = document.getElementById("G1").value * 2.55;
        pointB[2] = document.getElementById("B1").value * 2.55;
        pointB[3] = document.getElementById("A1").value * 2.55;

        pointC[0] = document.getElementById("R2").value * 2.55;
        pointC[1] = document.getElementById("G2").value * 2.55;
        pointC[2] = document.getElementById("B2").value * 2.55;
        pointC[3] = document.getElementById("A2").value * 2.55;

        pointD[0] = document.getElementById("R3").value * 2.55;
        pointD[1] = document.getElementById("G3").value * 2.55;
        pointD[2] = document.getElementById("B3").value * 2.55;
        pointD[3] = document.getElementById("A3").value * 2.55;

        //A B B C
        //B C C D
        bezierTexture = createTexture(
            [pointA[0],pointA[1],pointA[2],pointA[3],
             pointB[0],pointB[1],pointB[2],pointB[3],
             pointB[0],pointB[1],pointB[2],pointB[3],
             pointC[0],pointC[1],pointC[2],pointC[3],

             pointB[0],pointB[1],pointB[2],pointB[3],
             pointC[0],pointC[1],pointC[2],pointC[3],
             pointC[0],pointC[1],pointC[2],pointC[3],
             pointD[0],pointD[1],pointD[2],pointD[3],
             ],
             4, 2
        );
    }

    var screenQuadBuffer;
    var controlPointBuffer;

    function initBuffers() {
    	// make the full screen quad vertex buffer
        screenQuadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,
             1.0, -1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0,  1.0,
            -1.0,  1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        screenQuadBuffer.itemSize = 2;
        screenQuadBuffer.numItems = 6;

        // make the control point quad vertex buffer
        controlPointBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, controlPointBuffer);
        var size = 0.025;
        vertices = [
            // Front face
            -size, -size,
             size, -size,
             size,  size,
            -size, -size,
             size,  size,
            -size,  size,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        controlPointBuffer.itemSize = 2;
        controlPointBuffer.numItems = 6;        
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // draw the full screen quad
		gl.useProgram(FSshaderProgram);
        gl.bindBuffer(gl.ARRAY_BUFFER, screenQuadBuffer);
        gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, screenQuadBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bezierTexture);
        gl.uniform1i(FSshaderProgram.samplerUniform, 0);
        gl.drawArrays(gl.TRIANGLES,0,screenQuadBuffer.numItems);

        // draw the control points
        gl.useProgram(CPshaderProgram);        
        gl.bindBuffer(gl.ARRAY_BUFFER, controlPointBuffer);
        gl.vertexAttribPointer(FSshaderProgram.vertexPositionAttribute, controlPointBuffer.itemSize, gl.FLOAT, false, 0, 0);

        // Draw Red curve control points
        gl.uniform3f(CPshaderProgram.uColorLocation, 0.75, 0, 0);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1, 2.0 * (pointA[0]/255.0 - 0.5));
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1/3, 2.0 * (pointB[0]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, 1/3, 2.0 * (pointC[0]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
        gl.uniform2f(CPshaderProgram.uOffsetLocation, 1.0, 2.0 * (pointD[0]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);

        // Draw Green curve control points
        gl.uniform3f(CPshaderProgram.uColorLocation, 0, 0.75, 0);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1, 2.0 * (pointA[1]/255.0 - 0.5));
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1/3, 2.0 * (pointB[1]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, 1/3, 2.0 * (pointC[1]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
        gl.uniform2f(CPshaderProgram.uOffsetLocation, 1, 2.0 * (pointD[1]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);

        // Draw Blue curve control points
        gl.uniform3f(CPshaderProgram.uColorLocation, 0, 0, 0.75);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1, 2.0 * (pointA[2]/255.0 - 0.5));
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1/3, 2.0 * (pointB[2]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, 1/3, 2.0 * (pointC[2]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
        gl.uniform2f(CPshaderProgram.uOffsetLocation, 1, 2.0 * (pointD[2]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);

        // Draw Alpha curve control points
        gl.uniform3f(CPshaderProgram.uColorLocation, 0.75, 0.75, 0.75);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1, 2.0 * (pointA[3]/255.0 - 0.5));
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, -1/3, 2.0 * (pointB[3]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
		gl.uniform2f(CPshaderProgram.uOffsetLocation, 1/3, 2.0 * (pointC[3]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
        gl.uniform2f(CPshaderProgram.uOffsetLocation, 1, 2.0 * (pointD[3]/255.0 - 0.5));        
        gl.drawArrays(gl.TRIANGLES,0,controlPointBuffer.numItems);
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        g_frameCounter++;
    }

    function webGLStart() {
        var canvas = document.getElementById("webglcanvas");
        var canvassize = document.getElementById("CanvasSize").value;
        canvas.width = canvassize;
        canvas.height = canvassize;
        // details of options below here: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
        gl = WebGLUtils.setupWebGL(canvas, {alpha:true, depth: false, stencil: false, antialias: false, premultipliedAlpha:false, preserveDrawingBuffer: false});
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
    }

    function DoOnLoad() {
    	webGLStart();
    	setInterval(function(){ document.getElementById("fps").innerText = "FPS: " + g_frameCounter + " (" + Math.round(100 * 1000.0/g_frameCounter) / 100 + " ms)"; g_frameCounter = 0; }, 1000);
        tick();
    }

    function ResizeCanvas() {
    	webGLStart();
    }
</script>
</head>

<body onload="DoOnLoad()">
    <h1>Cubic Bezier Curve</h1>
    A cubic Bezier curve encoded within a 4x2 RGBA 8BPP texture image. Curve points evaluated by linear interpolating two quadratic bezier curves generated  using bilinear texture filtering.  If WebGL supported volumetric textures, those could be used to make evaluation with trilinear texture filtering like the C++ OpenGL demo does.  Cubic bezier equation evaluated curve also presented for comparison.<br>
    <a href="index.html">Back to Index</a><br><br>    
    <table>
	    <tr>
		    <td>Evaluation:</td>
		    <td>
			    <select id="EvaluationMode" onChange="initShaders();initTexture();">
			    	<option value="bilinear">Lerped Bilinear Texture Filtering</option>
			    	<option value="equation">Cubic Bezier Equation</option>
			    </select>
		    </td>
	    </tr>
	    <tr>
		    <td>Render:</td>
		    <td>
			    <select id="RenderMode" onChange="initShaders();initTexture();">
			    	<option value="halfspace">HalfSpace</option>
			    	<option value="curves">Curves</option>
                    <option value="texture">Texture</option>
			    </select>
			</td>
		</tr>
		<tr>
		    <td>Resolution:</td>
		    <td><select id="CanvasSize" onChange="ResizeCanvas();">
		    	<option value="250">250x250</option>
		    	<option value="500" selected="selected">500x500</option>
		    	<option value="1000">1000x1000</option>
		    </select>
		    </td>
	    </tr>
    </table>
    <div id="fps">FPS: --</div>
    <table>
        <tr>
            <td>
                <canvas id="webglcanvas" style="border: none" width="500" height="500"></canvas>
            </td>
            <td valign="top" style="border:2px solid red">
                Red:<br>
                1:<input type="range" min="0" max="100" id="R0" onInput="initTexture();" onChange="initTexture();" value="50"><br>
                2:<input type="range" min="0" max="100" id="R1" onInput="initTexture();" onChange="initTexture();" value="0"><br>
                3:<input type="range" min="0" max="100" id="R2" onInput="initTexture();" onChange="initTexture();" value="75"><br>
                4:<input type="range" min="0" max="100" id="R3" onInput="initTexture();" onChange="initTexture();" value="25"><br>
            </td>
            <td valign="top" style="border:2px solid green">                
                Green:<br>
                1:<input type="range" min="0" max="100" id="G0" onInput="initTexture();" onChange="initTexture();" value="0"><br>
                2:<input type="range" min="0" max="100" id="G1" onInput="initTexture();" onChange="initTexture();" value="100"><br>
                3:<input type="range" min="0" max="100" id="G2" onInput="initTexture();" onChange="initTexture();" value="25"><br>
                4:<input type="range" min="0" max="100" id="G3" onInput="initTexture();" onChange="initTexture();" value="75"><br>
            </td>
            <td valign="top" style="border:2px solid blue">                
                Blue:<br>
                1:<input type="range" min="0" max="100" id="B0" onInput="initTexture();" onChange="initTexture();" value="20"><br>
                2:<input type="range" min="0" max="100" id="B1" onInput="initTexture();" onChange="initTexture();" value="0"><br>
                3:<input type="range" min="0" max="100" id="B2" onInput="initTexture();" onChange="initTexture();" value="100"><br>
                4:<input type="range" min="0" max="100" id="B3" onInput="initTexture();" onChange="initTexture();" value="70"><br>
            </td>
            <td valign="top" style="border:2px solid black">                
                Alpha:<br>
                1:<input type="range" min="0" max="100" id="A0" onInput="initTexture();" onChange="initTexture();" value="75"><br>
                2:<input type="range" min="0" max="100" id="A1" onInput="initTexture();" onChange="initTexture();" value="0"><br>
                3:<input type="range" min="0" max="100" id="A2" onInput="initTexture();" onChange="initTexture();" value="30"><br>
                4:<input type="range" min="0" max="100" id="A3" onInput="initTexture();" onChange="initTexture();" value="60"><br>
            </td>
        </tr>
    </table>
    <a href="index.html">Back to Index</a>
</body>

</html>